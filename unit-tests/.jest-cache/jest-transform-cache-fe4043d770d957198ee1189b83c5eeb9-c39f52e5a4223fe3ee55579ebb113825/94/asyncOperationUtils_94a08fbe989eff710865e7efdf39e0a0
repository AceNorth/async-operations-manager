903a2ec34b8188186aadf408473dc3ee
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getActionForAsyncOperation = exports.rejectWriteAsyncOperation = exports.rejectReadAsyncOperation = exports.resolveWriteAsyncOperation = exports.resolveReadAsyncOperation = exports.beginWriteAsyncOperation = exports.beginReadAsyncOperation = exports.initialWriteAsyncOperationForAction = exports.initialReadAsyncOperationForAction = void 0;

require("core-js/modules/web.dom.iterable");

var _lodash = _interopRequireDefault(require("lodash"));

var _constants = require("./constants");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};var target = _objectWithoutPropertiesLoose(source, excluded);var key, i;if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];if (excluded.indexOf(key) >= 0) continue;if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;target[key] = source[key];
    }
  }return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};var target = {};var sourceKeys = Object.keys(source);var key, i;for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];if (excluded.indexOf(key) >= 0) continue;target[key] = source[key];
  }return target;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};var ownKeys = Object.keys(source);if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }return obj;
}

// An asyncOperation is an object that tracks the status of some data that we fetch from
// somewhere or send to somewhere. Each asyncOperation represents
// a single 'dataset' (which, today, always means a single ajax request -- although that's
// not a fixed constraint), and they're stored in Redux under operation-specific keys.
//
// "read" and "write" operations are *slightly* different, but they work the same way.
//
// The asyncOperation tracks information about:
//  - Our last attempt to fetch or write the data
//  - Whether we have data from a prior successful attempt (for reads only)
//  - The action and params and such that were used to request the data
//
// This file includes standalone functions that transform asyncOperations when we
// begin, resolve, or reject requests. In general, only reducers should use these functions.

/**
 * asyncOperations were originally always treated as proper immutable objects, but for background refreshes
 * it doesn't make sense to create a new object unless the status is actually different somehow, because
 * the new object will cause any screens that select the asyncOperation to rerender.
 *
 * So this is an experiment in having the asyncOperation object be *semi*-immutable: it will only yield
 * a new object instance if there's a noteworthy change in status.
 *
 * @type {boolean}
 */
const alwaysImmutable = false;
/**
 * This is the default look of brand new, never-touched asyncOperation.
 */

const initialReadAsyncOperation = {
  // Note that descriptorId is NOT included here: it MUST be provided!
  fetchStatus: _constants.FETCH_STATUS.NULL,
  dataStatus: _constants.DATA_STATUS.ABSENT,
  message: null,
  lastFetchStatusTime: 0,
  lastFetchFailed: false,
  lastDataStatusTime: 0
};
const initialWriteAsyncOperation = {
  // Note that descriptorId is NOT included here: it MUST be provided!
  fetchStatus: _constants.FETCH_STATUS.NULL,
  message: null,
  lastFetchStatusTime: 0
}; // BUT TWFetchData needs an descriptorId, so we'll export a helper that gives you that.
// This is really just syntactic sugar, but requiring people to use this ensures that
// we always have descriptorId.
// Note that we'll pull in any status (dataStatus, fetchStatus, etc) from the parent
// operation (which *should* be fetchAllBeveragesForOrg) to seed the initial status.

const initialReadAsyncOperationForAction = function initialReadAsyncOperationForAction(descriptorId) {
  let fieldsToAdd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  let parentAsyncOperation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  return _objectSpread({}, initialReadAsyncOperation, parentAsyncOperation ? _lodash.default.pick(parentAsyncOperation, _constants.readAsyncOperationFieldsToPullFromParent) : {}, fieldsToAdd, {
    descriptorId
  });
};

exports.initialReadAsyncOperationForAction = initialReadAsyncOperationForAction;

const initialWriteAsyncOperationForAction = function initialWriteAsyncOperationForAction(descriptorId) {
  let fieldsToAdd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return _objectSpread({}, initialWriteAsyncOperation, fieldsToAdd, {
    descriptorId
  });
};
/**
 * These are intended for use in reducers, when a __BEGIN action comes in:
 * For read operations, we'll retain any prior dataStatus, but everything else gets reset.
 * Write operations are always a new, blank backendAsyncOperation.
 *
 * Note that you'll always want to specify `descriptorId` in fieldsToAdd, along with any IDs.
 */

exports.initialWriteAsyncOperationForAction = initialWriteAsyncOperationForAction;

const beginReadAsyncOperation = function beginReadAsyncOperation() {
  let previousAsyncOperation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialReadAsyncOperation;
  let fieldsToAdd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  const fieldsForNewAsyncOperation = _objectSpread({
    // We re-initialize the entire operation state (except descriptorId and dataStatus) on __BEGIN.
    // (resolve/reject *don't* re-initialize: they carry through any IDs or other fields from before)
    descriptorId: previousAsyncOperation.descriptorId,
    fetchStatus: _constants.FETCH_STATUS.PENDING,
    dataStatus: previousAsyncOperation.dataStatus,
    message: null,
    lastFetchStatusTime: Date.now(),
    lastDataStatusTime: previousAsyncOperation.lastDataStatusTime
  }, fieldsToAdd);

  if (alwaysImmutable || previousAsyncOperation.dataStatus !== _constants.DATA_STATUS.PRESENT) {
    return fieldsForNewAsyncOperation;
  }

  Object.assign(previousAsyncOperation, fieldsForNewAsyncOperation);
  return previousAsyncOperation;
}; // Note that the 'write' works the same way as 'read', but instead of calling the base
// operation "previousAsyncOperation" we call it "initialAsyncOperation" since its role is different.


exports.beginReadAsyncOperation = beginReadAsyncOperation;

const beginWriteAsyncOperation = function beginWriteAsyncOperation() {
  let initialAsyncOperation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialWriteAsyncOperation;
  let fieldsToAdd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return _objectSpread({
    descriptorId: initialAsyncOperation.descriptorId,
    fetchStatus: _constants.FETCH_STATUS.PENDING,
    message: null,
    lastFetchStatusTime: Date.now()
  }, fieldsToAdd);
};
/**
 * These are intended for use in reducers, when a __RESOLVE action comes in:
 * we'll mark that we have data, and will overwrite any prior data status.
 */

exports.beginWriteAsyncOperation = beginWriteAsyncOperation;

const resolveReadAsyncOperation = function resolveReadAsyncOperation() {
  let previousAsyncOperation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialReadAsyncOperation;
  let fieldsToAdd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const currentTime = Date.now();

  const fieldsToUpdate = _objectSpread({
    fetchStatus: _constants.FETCH_STATUS.SUCCESSFUL,
    dataStatus: _constants.DATA_STATUS.PRESENT,
    lastFetchStatusTime: currentTime,
    lastFetchFailed: false,
    lastDataStatusTime: currentTime
  }, fieldsToAdd);

  if (alwaysImmutable || previousAsyncOperation.lastFetchFailed || previousAsyncOperation.dataStatus !== _constants.DATA_STATUS.PRESENT) {
    return _objectSpread({}, previousAsyncOperation, fieldsToUpdate);
  } // Else: we already had data, and we weren't asked to be immutable, so this isn't a noteworthy change,
  // so mutate in place. (Eep)


  Object.assign(previousAsyncOperation, fieldsToUpdate);
  return previousAsyncOperation;
};

exports.resolveReadAsyncOperation = resolveReadAsyncOperation;

const resolveWriteAsyncOperation = function resolveWriteAsyncOperation() {
  let previousAsyncOperation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialReadAsyncOperation;
  let fieldsToAdd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const currentTime = Date.now();
  return _objectSpread({}, previousAsyncOperation, {
    fetchStatus: _constants.FETCH_STATUS.SUCCESSFUL,
    lastFetchStatusTime: currentTime
  }, fieldsToAdd);
};
/**
 * These are intended for use in reducers, when a __REJECT action comes in:
 * we'll mark that things failed, but won't alter any prior data status (if it's a read).
 *
 * Note that you'll almost always want to specify `message` in fieldsToAdd.
 */

exports.resolveWriteAsyncOperation = resolveWriteAsyncOperation;

const rejectReadAsyncOperation = function rejectReadAsyncOperation() {
  let previousAsyncOperation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialReadAsyncOperation;
  let fieldsToAdd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return _objectSpread({}, previousAsyncOperation, {
    fetchStatus: _constants.FETCH_STATUS.FAILED,
    lastFetchStatusTime: Date.now(),
    lastFetchFailed: true
  }, fieldsToAdd);
};

exports.rejectReadAsyncOperation = rejectReadAsyncOperation;

const rejectWriteAsyncOperation = function rejectWriteAsyncOperation(previousAsyncOperation) {
  let fieldsToAdd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return _objectSpread({}, previousAsyncOperation, {
    fetchStatus: _constants.FETCH_STATUS.FAILED,
    lastFetchStatusTime: Date.now()
  }, fieldsToAdd);
};

exports.rejectWriteAsyncOperation = rejectWriteAsyncOperation;

const getActionForAsyncOperation = function getActionForAsyncOperation(operation, configContainer) {
  let extraParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  // We're going to pull out all the fields we recognize -- for both Read and Write operations --
  // and anything left over is assumed to be part of the action (i.e., any necessary IDs or params)
  const fetchStatus = operation.fetchStatus,
        dataStatus = operation.dataStatus,
        message = operation.message,
        lastFetchStatusTime = operation.lastFetchStatusTime,
        lastDataStatusTime = operation.lastDataStatusTime,
        descriptorId = operation.descriptorId,
        otherProps = _objectWithoutProperties(operation, ["fetchStatus", "dataStatus", "message", "lastFetchStatusTime", "lastDataStatusTime", "descriptorId"]);

  if (!descriptorId) {
    console.warn('AsyncOperation needs to include descriptorId so that we can re-dispatch it.', operation);
  }

  return _objectSpread({
    type: descriptorId,
    configContainer
  }, otherProps, extraParams);
};

exports.getActionForAsyncOperation = getActionForAsyncOperation;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzeW5jT3BlcmF0aW9uVXRpbHMuanMiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXRBY3Rpb25Gb3JBc3luY09wZXJhdGlvbiIsInJlamVjdFdyaXRlQXN5bmNPcGVyYXRpb24iLCJyZWplY3RSZWFkQXN5bmNPcGVyYXRpb24iLCJyZXNvbHZlV3JpdGVBc3luY09wZXJhdGlvbiIsInJlc29sdmVSZWFkQXN5bmNPcGVyYXRpb24iLCJiZWdpbldyaXRlQXN5bmNPcGVyYXRpb24iLCJiZWdpblJlYWRBc3luY09wZXJhdGlvbiIsImluaXRpYWxXcml0ZUFzeW5jT3BlcmF0aW9uRm9yQWN0aW9uIiwiaW5pdGlhbFJlYWRBc3luY09wZXJhdGlvbkZvckFjdGlvbiIsInJlcXVpcmUiLCJfbG9kYXNoIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9jb25zdGFudHMiLCJvYmoiLCJfX2VzTW9kdWxlIiwiZGVmYXVsdCIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsInNvdXJjZSIsImV4Y2x1ZGVkIiwidGFyZ2V0IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJrZXkiLCJpIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic291cmNlU3ltYm9sS2V5cyIsImxlbmd0aCIsImluZGV4T2YiLCJwcm90b3R5cGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImNhbGwiLCJzb3VyY2VLZXlzIiwia2V5cyIsIl9vYmplY3RTcHJlYWQiLCJhcmd1bWVudHMiLCJvd25LZXlzIiwiY29uY2F0IiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImFsd2F5c0ltbXV0YWJsZSIsImluaXRpYWxSZWFkQXN5bmNPcGVyYXRpb24iLCJmZXRjaFN0YXR1cyIsIkZFVENIX1NUQVRVUyIsIk5VTEwiLCJkYXRhU3RhdHVzIiwiREFUQV9TVEFUVVMiLCJBQlNFTlQiLCJtZXNzYWdlIiwibGFzdEZldGNoU3RhdHVzVGltZSIsImxhc3RGZXRjaEZhaWxlZCIsImxhc3REYXRhU3RhdHVzVGltZSIsImluaXRpYWxXcml0ZUFzeW5jT3BlcmF0aW9uIiwiZGVzY3JpcHRvcklkIiwiZmllbGRzVG9BZGQiLCJ1bmRlZmluZWQiLCJwYXJlbnRBc3luY09wZXJhdGlvbiIsInBpY2siLCJyZWFkQXN5bmNPcGVyYXRpb25GaWVsZHNUb1B1bGxGcm9tUGFyZW50IiwicHJldmlvdXNBc3luY09wZXJhdGlvbiIsImZpZWxkc0Zvck5ld0FzeW5jT3BlcmF0aW9uIiwiUEVORElORyIsIkRhdGUiLCJub3ciLCJQUkVTRU5UIiwiYXNzaWduIiwiaW5pdGlhbEFzeW5jT3BlcmF0aW9uIiwiY3VycmVudFRpbWUiLCJmaWVsZHNUb1VwZGF0ZSIsIlNVQ0NFU1NGVUwiLCJGQUlMRUQiLCJvcGVyYXRpb24iLCJjb25maWdDb250YWluZXIiLCJleHRyYVBhcmFtcyIsIm90aGVyUHJvcHMiLCJjb25zb2xlIiwid2FybiIsInR5cGUiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBQSxPQUFPQyxjQUFQLENBQXNCQyxPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUMzQ0MsU0FBTztBQURvQyxDQUE3QztBQUdBRCxRQUFRRSwwQkFBUixHQUFxQ0YsUUFBUUcseUJBQVIsR0FBb0NILFFBQVFJLHdCQUFSLEdBQW1DSixRQUFRSywwQkFBUixHQUFxQ0wsUUFBUU0seUJBQVIsR0FBb0NOLFFBQVFPLHdCQUFSLEdBQW1DUCxRQUFRUSx1QkFBUixHQUFrQ1IsUUFBUVMsbUNBQVIsR0FBOENULFFBQVFVLGtDQUFSLEdBQTZDLEtBQUssQ0FBMVY7O0FBRUFDLFFBQVEsa0NBQVI7O0FBRUEsSUFBSUMsVUFBVUMsdUJBQXVCRixRQUFRLFFBQVIsQ0FBdkIsQ0FBZDs7QUFFQSxJQUFJRyxhQUFhSCxRQUFRLGFBQVIsQ0FBakI7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XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldEFjdGlvbkZvckFzeW5jT3BlcmF0aW9uID0gZXhwb3J0cy5yZWplY3RXcml0ZUFzeW5jT3BlcmF0aW9uID0gZXhwb3J0cy5yZWplY3RSZWFkQXN5bmNPcGVyYXRpb24gPSBleHBvcnRzLnJlc29sdmVXcml0ZUFzeW5jT3BlcmF0aW9uID0gZXhwb3J0cy5yZXNvbHZlUmVhZEFzeW5jT3BlcmF0aW9uID0gZXhwb3J0cy5iZWdpbldyaXRlQXN5bmNPcGVyYXRpb24gPSBleHBvcnRzLmJlZ2luUmVhZEFzeW5jT3BlcmF0aW9uID0gZXhwb3J0cy5pbml0aWFsV3JpdGVBc3luY09wZXJhdGlvbkZvckFjdGlvbiA9IGV4cG9ydHMuaW5pdGlhbFJlYWRBc3luY09wZXJhdGlvbkZvckFjdGlvbiA9IHZvaWQgMDtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlXCIpO1xuXG52YXIgX2xvZGFzaCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImxvZGFzaFwiKSk7XG5cbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHsgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTsgfSkpOyB9IG93bktleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8vIEFuIGFzeW5jT3BlcmF0aW9uIGlzIGFuIG9iamVjdCB0aGF0IHRyYWNrcyB0aGUgc3RhdHVzIG9mIHNvbWUgZGF0YSB0aGF0IHdlIGZldGNoIGZyb21cbi8vIHNvbWV3aGVyZSBvciBzZW5kIHRvIHNvbWV3aGVyZS4gRWFjaCBhc3luY09wZXJhdGlvbiByZXByZXNlbnRzXG4vLyBhIHNpbmdsZSAnZGF0YXNldCcgKHdoaWNoLCB0b2RheSwgYWx3YXlzIG1lYW5zIGEgc2luZ2xlIGFqYXggcmVxdWVzdCAtLSBhbHRob3VnaCB0aGF0J3Ncbi8vIG5vdCBhIGZpeGVkIGNvbnN0cmFpbnQpLCBhbmQgdGhleSdyZSBzdG9yZWQgaW4gUmVkdXggdW5kZXIgb3BlcmF0aW9uLXNwZWNpZmljIGtleXMuXG4vL1xuLy8gXCJyZWFkXCIgYW5kIFwid3JpdGVcIiBvcGVyYXRpb25zIGFyZSAqc2xpZ2h0bHkqIGRpZmZlcmVudCwgYnV0IHRoZXkgd29yayB0aGUgc2FtZSB3YXkuXG4vL1xuLy8gVGhlIGFzeW5jT3BlcmF0aW9uIHRyYWNrcyBpbmZvcm1hdGlvbiBhYm91dDpcbi8vICAtIE91ciBsYXN0IGF0dGVtcHQgdG8gZmV0Y2ggb3Igd3JpdGUgdGhlIGRhdGFcbi8vICAtIFdoZXRoZXIgd2UgaGF2ZSBkYXRhIGZyb20gYSBwcmlvciBzdWNjZXNzZnVsIGF0dGVtcHQgKGZvciByZWFkcyBvbmx5KVxuLy8gIC0gVGhlIGFjdGlvbiBhbmQgcGFyYW1zIGFuZCBzdWNoIHRoYXQgd2VyZSB1c2VkIHRvIHJlcXVlc3QgdGhlIGRhdGFcbi8vXG4vLyBUaGlzIGZpbGUgaW5jbHVkZXMgc3RhbmRhbG9uZSBmdW5jdGlvbnMgdGhhdCB0cmFuc2Zvcm0gYXN5bmNPcGVyYXRpb25zIHdoZW4gd2Vcbi8vIGJlZ2luLCByZXNvbHZlLCBvciByZWplY3QgcmVxdWVzdHMuIEluIGdlbmVyYWwsIG9ubHkgcmVkdWNlcnMgc2hvdWxkIHVzZSB0aGVzZSBmdW5jdGlvbnMuXG5cbi8qKlxuICogYXN5bmNPcGVyYXRpb25zIHdlcmUgb3JpZ2luYWxseSBhbHdheXMgdHJlYXRlZCBhcyBwcm9wZXIgaW1tdXRhYmxlIG9iamVjdHMsIGJ1dCBmb3IgYmFja2dyb3VuZCByZWZyZXNoZXNcbiAqIGl0IGRvZXNuJ3QgbWFrZSBzZW5zZSB0byBjcmVhdGUgYSBuZXcgb2JqZWN0IHVubGVzcyB0aGUgc3RhdHVzIGlzIGFjdHVhbGx5IGRpZmZlcmVudCBzb21laG93LCBiZWNhdXNlXG4gKiB0aGUgbmV3IG9iamVjdCB3aWxsIGNhdXNlIGFueSBzY3JlZW5zIHRoYXQgc2VsZWN0IHRoZSBhc3luY09wZXJhdGlvbiB0byByZXJlbmRlci5cbiAqXG4gKiBTbyB0aGlzIGlzIGFuIGV4cGVyaW1lbnQgaW4gaGF2aW5nIHRoZSBhc3luY09wZXJhdGlvbiBvYmplY3QgYmUgKnNlbWkqLWltbXV0YWJsZTogaXQgd2lsbCBvbmx5IHlpZWxkXG4gKiBhIG5ldyBvYmplY3QgaW5zdGFuY2UgaWYgdGhlcmUncyBhIG5vdGV3b3J0aHkgY2hhbmdlIGluIHN0YXR1cy5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgYWx3YXlzSW1tdXRhYmxlID0gZmFsc2U7XG4vKipcbiAqIFRoaXMgaXMgdGhlIGRlZmF1bHQgbG9vayBvZiBicmFuZCBuZXcsIG5ldmVyLXRvdWNoZWQgYXN5bmNPcGVyYXRpb24uXG4gKi9cblxuY29uc3QgaW5pdGlhbFJlYWRBc3luY09wZXJhdGlvbiA9IHtcbiAgLy8gTm90ZSB0aGF0IGRlc2NyaXB0b3JJZCBpcyBOT1QgaW5jbHVkZWQgaGVyZTogaXQgTVVTVCBiZSBwcm92aWRlZCFcbiAgZmV0Y2hTdGF0dXM6IF9jb25zdGFudHMuRkVUQ0hfU1RBVFVTLk5VTEwsXG4gIGRhdGFTdGF0dXM6IF9jb25zdGFudHMuREFUQV9TVEFUVVMuQUJTRU5ULFxuICBtZXNzYWdlOiBudWxsLFxuICBsYXN0RmV0Y2hTdGF0dXNUaW1lOiAwLFxuICBsYXN0RmV0Y2hGYWlsZWQ6IGZhbHNlLFxuICBsYXN0RGF0YVN0YXR1c1RpbWU6IDBcbn07XG5jb25zdCBpbml0aWFsV3JpdGVBc3luY09wZXJhdGlvbiA9IHtcbiAgLy8gTm90ZSB0aGF0IGRlc2NyaXB0b3JJZCBpcyBOT1QgaW5jbHVkZWQgaGVyZTogaXQgTVVTVCBiZSBwcm92aWRlZCFcbiAgZmV0Y2hTdGF0dXM6IF9jb25zdGFudHMuRkVUQ0hfU1RBVFVTLk5VTEwsXG4gIG1lc3NhZ2U6IG51bGwsXG4gIGxhc3RGZXRjaFN0YXR1c1RpbWU6IDBcbn07IC8vIEJVVCBUV0ZldGNoRGF0YSBuZWVkcyBhbiBkZXNjcmlwdG9ySWQsIHNvIHdlJ2xsIGV4cG9ydCBhIGhlbHBlciB0aGF0IGdpdmVzIHlvdSB0aGF0LlxuLy8gVGhpcyBpcyByZWFsbHkganVzdCBzeW50YWN0aWMgc3VnYXIsIGJ1dCByZXF1aXJpbmcgcGVvcGxlIHRvIHVzZSB0aGlzIGVuc3VyZXMgdGhhdFxuLy8gd2UgYWx3YXlzIGhhdmUgZGVzY3JpcHRvcklkLlxuLy8gTm90ZSB0aGF0IHdlJ2xsIHB1bGwgaW4gYW55IHN0YXR1cyAoZGF0YVN0YXR1cywgZmV0Y2hTdGF0dXMsIGV0YykgZnJvbSB0aGUgcGFyZW50XG4vLyBvcGVyYXRpb24gKHdoaWNoICpzaG91bGQqIGJlIGZldGNoQWxsQmV2ZXJhZ2VzRm9yT3JnKSB0byBzZWVkIHRoZSBpbml0aWFsIHN0YXR1cy5cblxuY29uc3QgaW5pdGlhbFJlYWRBc3luY09wZXJhdGlvbkZvckFjdGlvbiA9IGZ1bmN0aW9uIGluaXRpYWxSZWFkQXN5bmNPcGVyYXRpb25Gb3JBY3Rpb24oZGVzY3JpcHRvcklkKSB7XG4gIGxldCBmaWVsZHNUb0FkZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGxldCBwYXJlbnRBc3luY09wZXJhdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe30sIGluaXRpYWxSZWFkQXN5bmNPcGVyYXRpb24sIHBhcmVudEFzeW5jT3BlcmF0aW9uID8gX2xvZGFzaC5kZWZhdWx0LnBpY2socGFyZW50QXN5bmNPcGVyYXRpb24sIF9jb25zdGFudHMucmVhZEFzeW5jT3BlcmF0aW9uRmllbGRzVG9QdWxsRnJvbVBhcmVudCkgOiB7fSwgZmllbGRzVG9BZGQsIHtcbiAgICBkZXNjcmlwdG9ySWRcbiAgfSk7XG59O1xuXG5leHBvcnRzLmluaXRpYWxSZWFkQXN5bmNPcGVyYXRpb25Gb3JBY3Rpb24gPSBpbml0aWFsUmVhZEFzeW5jT3BlcmF0aW9uRm9yQWN0aW9uO1xuXG5jb25zdCBpbml0aWFsV3JpdGVBc3luY09wZXJhdGlvbkZvckFjdGlvbiA9IGZ1bmN0aW9uIGluaXRpYWxXcml0ZUFzeW5jT3BlcmF0aW9uRm9yQWN0aW9uKGRlc2NyaXB0b3JJZCkge1xuICBsZXQgZmllbGRzVG9BZGQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICByZXR1cm4gX29iamVjdFNwcmVhZCh7fSwgaW5pdGlhbFdyaXRlQXN5bmNPcGVyYXRpb24sIGZpZWxkc1RvQWRkLCB7XG4gICAgZGVzY3JpcHRvcklkXG4gIH0pO1xufTtcbi8qKlxuICogVGhlc2UgYXJlIGludGVuZGVkIGZvciB1c2UgaW4gcmVkdWNlcnMsIHdoZW4gYSBfX0JFR0lOIGFjdGlvbiBjb21lcyBpbjpcbiAqIEZvciByZWFkIG9wZXJhdGlvbnMsIHdlJ2xsIHJldGFpbiBhbnkgcHJpb3IgZGF0YVN0YXR1cywgYnV0IGV2ZXJ5dGhpbmcgZWxzZSBnZXRzIHJlc2V0LlxuICogV3JpdGUgb3BlcmF0aW9ucyBhcmUgYWx3YXlzIGEgbmV3LCBibGFuayBiYWNrZW5kQXN5bmNPcGVyYXRpb24uXG4gKlxuICogTm90ZSB0aGF0IHlvdSdsbCBhbHdheXMgd2FudCB0byBzcGVjaWZ5IGBkZXNjcmlwdG9ySWRgIGluIGZpZWxkc1RvQWRkLCBhbG9uZyB3aXRoIGFueSBJRHMuXG4gKi9cblxuXG5leHBvcnRzLmluaXRpYWxXcml0ZUFzeW5jT3BlcmF0aW9uRm9yQWN0aW9uID0gaW5pdGlhbFdyaXRlQXN5bmNPcGVyYXRpb25Gb3JBY3Rpb247XG5cbmNvbnN0IGJlZ2luUmVhZEFzeW5jT3BlcmF0aW9uID0gZnVuY3Rpb24gYmVnaW5SZWFkQXN5bmNPcGVyYXRpb24oKSB7XG4gIGxldCBwcmV2aW91c0FzeW5jT3BlcmF0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBpbml0aWFsUmVhZEFzeW5jT3BlcmF0aW9uO1xuICBsZXQgZmllbGRzVG9BZGQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gIGNvbnN0IGZpZWxkc0Zvck5ld0FzeW5jT3BlcmF0aW9uID0gX29iamVjdFNwcmVhZCh7XG4gICAgLy8gV2UgcmUtaW5pdGlhbGl6ZSB0aGUgZW50aXJlIG9wZXJhdGlvbiBzdGF0ZSAoZXhjZXB0IGRlc2NyaXB0b3JJZCBhbmQgZGF0YVN0YXR1cykgb24gX19CRUdJTi5cbiAgICAvLyAocmVzb2x2ZS9yZWplY3QgKmRvbid0KiByZS1pbml0aWFsaXplOiB0aGV5IGNhcnJ5IHRocm91Z2ggYW55IElEcyBvciBvdGhlciBmaWVsZHMgZnJvbSBiZWZvcmUpXG4gICAgZGVzY3JpcHRvcklkOiBwcmV2aW91c0FzeW5jT3BlcmF0aW9uLmRlc2NyaXB0b3JJZCxcbiAgICBmZXRjaFN0YXR1czogX2NvbnN0YW50cy5GRVRDSF9TVEFUVVMuUEVORElORyxcbiAgICBkYXRhU3RhdHVzOiBwcmV2aW91c0FzeW5jT3BlcmF0aW9uLmRhdGFTdGF0dXMsXG4gICAgbWVzc2FnZTogbnVsbCxcbiAgICBsYXN0RmV0Y2hTdGF0dXNUaW1lOiBEYXRlLm5vdygpLFxuICAgIGxhc3REYXRhU3RhdHVzVGltZTogcHJldmlvdXNBc3luY09wZXJhdGlvbi5sYXN0RGF0YVN0YXR1c1RpbWVcbiAgfSwgZmllbGRzVG9BZGQpO1xuXG4gIGlmIChhbHdheXNJbW11dGFibGUgfHwgcHJldmlvdXNBc3luY09wZXJhdGlvbi5kYXRhU3RhdHVzICE9PSBfY29uc3RhbnRzLkRBVEFfU1RBVFVTLlBSRVNFTlQpIHtcbiAgICByZXR1cm4gZmllbGRzRm9yTmV3QXN5bmNPcGVyYXRpb247XG4gIH1cblxuICBPYmplY3QuYXNzaWduKHByZXZpb3VzQXN5bmNPcGVyYXRpb24sIGZpZWxkc0Zvck5ld0FzeW5jT3BlcmF0aW9uKTtcbiAgcmV0dXJuIHByZXZpb3VzQXN5bmNPcGVyYXRpb247XG59OyAvLyBOb3RlIHRoYXQgdGhlICd3cml0ZScgd29ya3MgdGhlIHNhbWUgd2F5IGFzICdyZWFkJywgYnV0IGluc3RlYWQgb2YgY2FsbGluZyB0aGUgYmFzZVxuLy8gb3BlcmF0aW9uIFwicHJldmlvdXNBc3luY09wZXJhdGlvblwiIHdlIGNhbGwgaXQgXCJpbml0aWFsQXN5bmNPcGVyYXRpb25cIiBzaW5jZSBpdHMgcm9sZSBpcyBkaWZmZXJlbnQuXG5cblxuZXhwb3J0cy5iZWdpblJlYWRBc3luY09wZXJhdGlvbiA9IGJlZ2luUmVhZEFzeW5jT3BlcmF0aW9uO1xuXG5jb25zdCBiZWdpbldyaXRlQXN5bmNPcGVyYXRpb24gPSBmdW5jdGlvbiBiZWdpbldyaXRlQXN5bmNPcGVyYXRpb24oKSB7XG4gIGxldCBpbml0aWFsQXN5bmNPcGVyYXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGluaXRpYWxXcml0ZUFzeW5jT3BlcmF0aW9uO1xuICBsZXQgZmllbGRzVG9BZGQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICByZXR1cm4gX29iamVjdFNwcmVhZCh7XG4gICAgZGVzY3JpcHRvcklkOiBpbml0aWFsQXN5bmNPcGVyYXRpb24uZGVzY3JpcHRvcklkLFxuICAgIGZldGNoU3RhdHVzOiBfY29uc3RhbnRzLkZFVENIX1NUQVRVUy5QRU5ESU5HLFxuICAgIG1lc3NhZ2U6IG51bGwsXG4gICAgbGFzdEZldGNoU3RhdHVzVGltZTogRGF0ZS5ub3coKVxuICB9LCBmaWVsZHNUb0FkZCk7XG59O1xuLyoqXG4gKiBUaGVzZSBhcmUgaW50ZW5kZWQgZm9yIHVzZSBpbiByZWR1Y2Vycywgd2hlbiBhIF9fUkVTT0xWRSBhY3Rpb24gY29tZXMgaW46XG4gKiB3ZSdsbCBtYXJrIHRoYXQgd2UgaGF2ZSBkYXRhLCBhbmQgd2lsbCBvdmVyd3JpdGUgYW55IHByaW9yIGRhdGEgc3RhdHVzLlxuICovXG5cblxuZXhwb3J0cy5iZWdpbldyaXRlQXN5bmNPcGVyYXRpb24gPSBiZWdpbldyaXRlQXN5bmNPcGVyYXRpb247XG5cbmNvbnN0IHJlc29sdmVSZWFkQXN5bmNPcGVyYXRpb24gPSBmdW5jdGlvbiByZXNvbHZlUmVhZEFzeW5jT3BlcmF0aW9uKCkge1xuICBsZXQgcHJldmlvdXNBc3luY09wZXJhdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogaW5pdGlhbFJlYWRBc3luY09wZXJhdGlvbjtcbiAgbGV0IGZpZWxkc1RvQWRkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gIGNvbnN0IGZpZWxkc1RvVXBkYXRlID0gX29iamVjdFNwcmVhZCh7XG4gICAgZmV0Y2hTdGF0dXM6IF9jb25zdGFudHMuRkVUQ0hfU1RBVFVTLlNVQ0NFU1NGVUwsXG4gICAgZGF0YVN0YXR1czogX2NvbnN0YW50cy5EQVRBX1NUQVRVUy5QUkVTRU5ULFxuICAgIGxhc3RGZXRjaFN0YXR1c1RpbWU6IGN1cnJlbnRUaW1lLFxuICAgIGxhc3RGZXRjaEZhaWxlZDogZmFsc2UsXG4gICAgbGFzdERhdGFTdGF0dXNUaW1lOiBjdXJyZW50VGltZVxuICB9LCBmaWVsZHNUb0FkZCk7XG5cbiAgaWYgKGFsd2F5c0ltbXV0YWJsZSB8fCBwcmV2aW91c0FzeW5jT3BlcmF0aW9uLmxhc3RGZXRjaEZhaWxlZCB8fCBwcmV2aW91c0FzeW5jT3BlcmF0aW9uLmRhdGFTdGF0dXMgIT09IF9jb25zdGFudHMuREFUQV9TVEFUVVMuUFJFU0VOVCkge1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHt9LCBwcmV2aW91c0FzeW5jT3BlcmF0aW9uLCBmaWVsZHNUb1VwZGF0ZSk7XG4gIH0gLy8gRWxzZTogd2UgYWxyZWFkeSBoYWQgZGF0YSwgYW5kIHdlIHdlcmVuJ3QgYXNrZWQgdG8gYmUgaW1tdXRhYmxlLCBzbyB0aGlzIGlzbid0IGEgbm90ZXdvcnRoeSBjaGFuZ2UsXG4gIC8vIHNvIG11dGF0ZSBpbiBwbGFjZS4gKEVlcClcblxuXG4gIE9iamVjdC5hc3NpZ24ocHJldmlvdXNBc3luY09wZXJhdGlvbiwgZmllbGRzVG9VcGRhdGUpO1xuICByZXR1cm4gcHJldmlvdXNBc3luY09wZXJhdGlvbjtcbn07XG5cbmV4cG9ydHMucmVzb2x2ZVJlYWRBc3luY09wZXJhdGlvbiA9IHJlc29sdmVSZWFkQXN5bmNPcGVyYXRpb247XG5cbmNvbnN0IHJlc29sdmVXcml0ZUFzeW5jT3BlcmF0aW9uID0gZnVuY3Rpb24gcmVzb2x2ZVdyaXRlQXN5bmNPcGVyYXRpb24oKSB7XG4gIGxldCBwcmV2aW91c0FzeW5jT3BlcmF0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBpbml0aWFsUmVhZEFzeW5jT3BlcmF0aW9uO1xuICBsZXQgZmllbGRzVG9BZGQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkKHt9LCBwcmV2aW91c0FzeW5jT3BlcmF0aW9uLCB7XG4gICAgZmV0Y2hTdGF0dXM6IF9jb25zdGFudHMuRkVUQ0hfU1RBVFVTLlNVQ0NFU1NGVUwsXG4gICAgbGFzdEZldGNoU3RhdHVzVGltZTogY3VycmVudFRpbWVcbiAgfSwgZmllbGRzVG9BZGQpO1xufTtcbi8qKlxuICogVGhlc2UgYXJlIGludGVuZGVkIGZvciB1c2UgaW4gcmVkdWNlcnMsIHdoZW4gYSBfX1JFSkVDVCBhY3Rpb24gY29tZXMgaW46XG4gKiB3ZSdsbCBtYXJrIHRoYXQgdGhpbmdzIGZhaWxlZCwgYnV0IHdvbid0IGFsdGVyIGFueSBwcmlvciBkYXRhIHN0YXR1cyAoaWYgaXQncyBhIHJlYWQpLlxuICpcbiAqIE5vdGUgdGhhdCB5b3UnbGwgYWxtb3N0IGFsd2F5cyB3YW50IHRvIHNwZWNpZnkgYG1lc3NhZ2VgIGluIGZpZWxkc1RvQWRkLlxuICovXG5cblxuZXhwb3J0cy5yZXNvbHZlV3JpdGVBc3luY09wZXJhdGlvbiA9IHJlc29sdmVXcml0ZUFzeW5jT3BlcmF0aW9uO1xuXG5jb25zdCByZWplY3RSZWFkQXN5bmNPcGVyYXRpb24gPSBmdW5jdGlvbiByZWplY3RSZWFkQXN5bmNPcGVyYXRpb24oKSB7XG4gIGxldCBwcmV2aW91c0FzeW5jT3BlcmF0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBpbml0aWFsUmVhZEFzeW5jT3BlcmF0aW9uO1xuICBsZXQgZmllbGRzVG9BZGQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICByZXR1cm4gX29iamVjdFNwcmVhZCh7fSwgcHJldmlvdXNBc3luY09wZXJhdGlvbiwge1xuICAgIGZldGNoU3RhdHVzOiBfY29uc3RhbnRzLkZFVENIX1NUQVRVUy5GQUlMRUQsXG4gICAgbGFzdEZldGNoU3RhdHVzVGltZTogRGF0ZS5ub3coKSxcbiAgICBsYXN0RmV0Y2hGYWlsZWQ6IHRydWVcbiAgfSwgZmllbGRzVG9BZGQpO1xufTtcblxuZXhwb3J0cy5yZWplY3RSZWFkQXN5bmNPcGVyYXRpb24gPSByZWplY3RSZWFkQXN5bmNPcGVyYXRpb247XG5cbmNvbnN0IHJlamVjdFdyaXRlQXN5bmNPcGVyYXRpb24gPSBmdW5jdGlvbiByZWplY3RXcml0ZUFzeW5jT3BlcmF0aW9uKHByZXZpb3VzQXN5bmNPcGVyYXRpb24pIHtcbiAgbGV0IGZpZWxkc1RvQWRkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe30sIHByZXZpb3VzQXN5bmNPcGVyYXRpb24sIHtcbiAgICBmZXRjaFN0YXR1czogX2NvbnN0YW50cy5GRVRDSF9TVEFUVVMuRkFJTEVELFxuICAgIGxhc3RGZXRjaFN0YXR1c1RpbWU6IERhdGUubm93KClcbiAgfSwgZmllbGRzVG9BZGQpO1xufTtcblxuZXhwb3J0cy5yZWplY3RXcml0ZUFzeW5jT3BlcmF0aW9uID0gcmVqZWN0V3JpdGVBc3luY09wZXJhdGlvbjtcblxuY29uc3QgZ2V0QWN0aW9uRm9yQXN5bmNPcGVyYXRpb24gPSBmdW5jdGlvbiBnZXRBY3Rpb25Gb3JBc3luY09wZXJhdGlvbihvcGVyYXRpb24sIGNvbmZpZ0NvbnRhaW5lcikge1xuICBsZXQgZXh0cmFQYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gIC8vIFdlJ3JlIGdvaW5nIHRvIHB1bGwgb3V0IGFsbCB0aGUgZmllbGRzIHdlIHJlY29nbml6ZSAtLSBmb3IgYm90aCBSZWFkIGFuZCBXcml0ZSBvcGVyYXRpb25zIC0tXG4gIC8vIGFuZCBhbnl0aGluZyBsZWZ0IG92ZXIgaXMgYXNzdW1lZCB0byBiZSBwYXJ0IG9mIHRoZSBhY3Rpb24gKGkuZS4sIGFueSBuZWNlc3NhcnkgSURzIG9yIHBhcmFtcylcbiAgY29uc3QgZmV0Y2hTdGF0dXMgPSBvcGVyYXRpb24uZmV0Y2hTdGF0dXMsXG4gICAgICAgIGRhdGFTdGF0dXMgPSBvcGVyYXRpb24uZGF0YVN0YXR1cyxcbiAgICAgICAgbWVzc2FnZSA9IG9wZXJhdGlvbi5tZXNzYWdlLFxuICAgICAgICBsYXN0RmV0Y2hTdGF0dXNUaW1lID0gb3BlcmF0aW9uLmxhc3RGZXRjaFN0YXR1c1RpbWUsXG4gICAgICAgIGxhc3REYXRhU3RhdHVzVGltZSA9IG9wZXJhdGlvbi5sYXN0RGF0YVN0YXR1c1RpbWUsXG4gICAgICAgIGRlc2NyaXB0b3JJZCA9IG9wZXJhdGlvbi5kZXNjcmlwdG9ySWQsXG4gICAgICAgIG90aGVyUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob3BlcmF0aW9uLCBbXCJmZXRjaFN0YXR1c1wiLCBcImRhdGFTdGF0dXNcIiwgXCJtZXNzYWdlXCIsIFwibGFzdEZldGNoU3RhdHVzVGltZVwiLCBcImxhc3REYXRhU3RhdHVzVGltZVwiLCBcImRlc2NyaXB0b3JJZFwiXSk7XG5cbiAgaWYgKCFkZXNjcmlwdG9ySWQpIHtcbiAgICBjb25zb2xlLndhcm4oJ0FzeW5jT3BlcmF0aW9uIG5lZWRzIHRvIGluY2x1ZGUgZGVzY3JpcHRvcklkIHNvIHRoYXQgd2UgY2FuIHJlLWRpc3BhdGNoIGl0LicsIG9wZXJhdGlvbik7XG4gIH1cblxuICByZXR1cm4gX29iamVjdFNwcmVhZCh7XG4gICAgdHlwZTogZGVzY3JpcHRvcklkLFxuICAgIGNvbmZpZ0NvbnRhaW5lclxuICB9LCBvdGhlclByb3BzLCBleHRyYVBhcmFtcyk7XG59O1xuXG5leHBvcnRzLmdldEFjdGlvbkZvckFzeW5jT3BlcmF0aW9uID0gZ2V0QWN0aW9uRm9yQXN5bmNPcGVyYXRpb247Il19