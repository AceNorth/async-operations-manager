{"version":3,"sources":["asyncOperationUtils.js"],"names":["Object","defineProperty","exports","value","getActionForAsyncOperation","rejectWriteAsyncOperation","rejectReadAsyncOperation","resolveWriteAsyncOperation","resolveReadAsyncOperation","beginWriteAsyncOperation","beginReadAsyncOperation","initialWriteAsyncOperationForAction","initialReadAsyncOperationForAction","require","_lodash","_interopRequireDefault","_constants","obj","__esModule","default","_objectWithoutProperties","source","excluded","target","_objectWithoutPropertiesLoose","key","i","getOwnPropertySymbols","sourceSymbolKeys","length","indexOf","prototype","propertyIsEnumerable","call","sourceKeys","keys","_objectSpread","arguments","ownKeys","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","_defineProperty","configurable","writable","alwaysImmutable","initialReadAsyncOperation","fetchStatus","FETCH_STATUS","NULL","dataStatus","DATA_STATUS","ABSENT","message","lastFetchStatusTime","lastFetchFailed","lastDataStatusTime","initialWriteAsyncOperation","descriptorId","fieldsToAdd","undefined","parentAsyncOperation","pick","readAsyncOperationFieldsToPullFromParent","previousAsyncOperation","fieldsForNewAsyncOperation","PENDING","Date","now","PRESENT","assign","initialAsyncOperation","currentTime","fieldsToUpdate","SUCCESSFUL","FAILED","operation","configContainer","extraParams","otherProps","console","warn","type"],"mappings":"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","file":"asyncOperationUtils.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getActionForAsyncOperation = exports.rejectWriteAsyncOperation = exports.rejectReadAsyncOperation = exports.resolveWriteAsyncOperation = exports.resolveReadAsyncOperation = exports.beginWriteAsyncOperation = exports.beginReadAsyncOperation = exports.initialWriteAsyncOperationForAction = exports.initialReadAsyncOperationForAction = void 0;\n\nrequire(\"core-js/modules/web.dom.iterable\");\n\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\n\nvar _constants = require(\"./constants\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// An asyncOperation is an object that tracks the status of some data that we fetch from\n// somewhere or send to somewhere. Each asyncOperation represents\n// a single 'dataset' (which, today, always means a single ajax request -- although that's\n// not a fixed constraint), and they're stored in Redux under operation-specific keys.\n//\n// \"read\" and \"write\" operations are *slightly* different, but they work the same way.\n//\n// The asyncOperation tracks information about:\n//  - Our last attempt to fetch or write the data\n//  - Whether we have data from a prior successful attempt (for reads only)\n//  - The action and params and such that were used to request the data\n//\n// This file includes standalone functions that transform asyncOperations when we\n// begin, resolve, or reject requests. In general, only reducers should use these functions.\n\n/**\n * asyncOperations were originally always treated as proper immutable objects, but for background refreshes\n * it doesn't make sense to create a new object unless the status is actually different somehow, because\n * the new object will cause any screens that select the asyncOperation to rerender.\n *\n * So this is an experiment in having the asyncOperation object be *semi*-immutable: it will only yield\n * a new object instance if there's a noteworthy change in status.\n *\n * @type {boolean}\n */\nconst alwaysImmutable = false;\n/**\n * This is the default look of brand new, never-touched asyncOperation.\n */\n\nconst initialReadAsyncOperation = {\n  // Note that descriptorId is NOT included here: it MUST be provided!\n  fetchStatus: _constants.FETCH_STATUS.NULL,\n  dataStatus: _constants.DATA_STATUS.ABSENT,\n  message: null,\n  lastFetchStatusTime: 0,\n  lastFetchFailed: false,\n  lastDataStatusTime: 0\n};\nconst initialWriteAsyncOperation = {\n  // Note that descriptorId is NOT included here: it MUST be provided!\n  fetchStatus: _constants.FETCH_STATUS.NULL,\n  message: null,\n  lastFetchStatusTime: 0\n}; // BUT TWFetchData needs an descriptorId, so we'll export a helper that gives you that.\n// This is really just syntactic sugar, but requiring people to use this ensures that\n// we always have descriptorId.\n// Note that we'll pull in any status (dataStatus, fetchStatus, etc) from the parent\n// operation (which *should* be fetchAllBeveragesForOrg) to seed the initial status.\n\nconst initialReadAsyncOperationForAction = function initialReadAsyncOperationForAction(descriptorId) {\n  let fieldsToAdd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let parentAsyncOperation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return _objectSpread({}, initialReadAsyncOperation, parentAsyncOperation ? _lodash.default.pick(parentAsyncOperation, _constants.readAsyncOperationFieldsToPullFromParent) : {}, fieldsToAdd, {\n    descriptorId\n  });\n};\n\nexports.initialReadAsyncOperationForAction = initialReadAsyncOperationForAction;\n\nconst initialWriteAsyncOperationForAction = function initialWriteAsyncOperationForAction(descriptorId) {\n  let fieldsToAdd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _objectSpread({}, initialWriteAsyncOperation, fieldsToAdd, {\n    descriptorId\n  });\n};\n/**\n * These are intended for use in reducers, when a __BEGIN action comes in:\n * For read operations, we'll retain any prior dataStatus, but everything else gets reset.\n * Write operations are always a new, blank backendAsyncOperation.\n *\n * Note that you'll always want to specify `descriptorId` in fieldsToAdd, along with any IDs.\n */\n\n\nexports.initialWriteAsyncOperationForAction = initialWriteAsyncOperationForAction;\n\nconst beginReadAsyncOperation = function beginReadAsyncOperation() {\n  let previousAsyncOperation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialReadAsyncOperation;\n  let fieldsToAdd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  const fieldsForNewAsyncOperation = _objectSpread({\n    // We re-initialize the entire operation state (except descriptorId and dataStatus) on __BEGIN.\n    // (resolve/reject *don't* re-initialize: they carry through any IDs or other fields from before)\n    descriptorId: previousAsyncOperation.descriptorId,\n    fetchStatus: _constants.FETCH_STATUS.PENDING,\n    dataStatus: previousAsyncOperation.dataStatus,\n    message: null,\n    lastFetchStatusTime: Date.now(),\n    lastDataStatusTime: previousAsyncOperation.lastDataStatusTime\n  }, fieldsToAdd);\n\n  if (alwaysImmutable || previousAsyncOperation.dataStatus !== _constants.DATA_STATUS.PRESENT) {\n    return fieldsForNewAsyncOperation;\n  }\n\n  Object.assign(previousAsyncOperation, fieldsForNewAsyncOperation);\n  return previousAsyncOperation;\n}; // Note that the 'write' works the same way as 'read', but instead of calling the base\n// operation \"previousAsyncOperation\" we call it \"initialAsyncOperation\" since its role is different.\n\n\nexports.beginReadAsyncOperation = beginReadAsyncOperation;\n\nconst beginWriteAsyncOperation = function beginWriteAsyncOperation() {\n  let initialAsyncOperation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialWriteAsyncOperation;\n  let fieldsToAdd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _objectSpread({\n    descriptorId: initialAsyncOperation.descriptorId,\n    fetchStatus: _constants.FETCH_STATUS.PENDING,\n    message: null,\n    lastFetchStatusTime: Date.now()\n  }, fieldsToAdd);\n};\n/**\n * These are intended for use in reducers, when a __RESOLVE action comes in:\n * we'll mark that we have data, and will overwrite any prior data status.\n */\n\n\nexports.beginWriteAsyncOperation = beginWriteAsyncOperation;\n\nconst resolveReadAsyncOperation = function resolveReadAsyncOperation() {\n  let previousAsyncOperation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialReadAsyncOperation;\n  let fieldsToAdd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const currentTime = Date.now();\n\n  const fieldsToUpdate = _objectSpread({\n    fetchStatus: _constants.FETCH_STATUS.SUCCESSFUL,\n    dataStatus: _constants.DATA_STATUS.PRESENT,\n    lastFetchStatusTime: currentTime,\n    lastFetchFailed: false,\n    lastDataStatusTime: currentTime\n  }, fieldsToAdd);\n\n  if (alwaysImmutable || previousAsyncOperation.lastFetchFailed || previousAsyncOperation.dataStatus !== _constants.DATA_STATUS.PRESENT) {\n    return _objectSpread({}, previousAsyncOperation, fieldsToUpdate);\n  } // Else: we already had data, and we weren't asked to be immutable, so this isn't a noteworthy change,\n  // so mutate in place. (Eep)\n\n\n  Object.assign(previousAsyncOperation, fieldsToUpdate);\n  return previousAsyncOperation;\n};\n\nexports.resolveReadAsyncOperation = resolveReadAsyncOperation;\n\nconst resolveWriteAsyncOperation = function resolveWriteAsyncOperation() {\n  let previousAsyncOperation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialReadAsyncOperation;\n  let fieldsToAdd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const currentTime = Date.now();\n  return _objectSpread({}, previousAsyncOperation, {\n    fetchStatus: _constants.FETCH_STATUS.SUCCESSFUL,\n    lastFetchStatusTime: currentTime\n  }, fieldsToAdd);\n};\n/**\n * These are intended for use in reducers, when a __REJECT action comes in:\n * we'll mark that things failed, but won't alter any prior data status (if it's a read).\n *\n * Note that you'll almost always want to specify `message` in fieldsToAdd.\n */\n\n\nexports.resolveWriteAsyncOperation = resolveWriteAsyncOperation;\n\nconst rejectReadAsyncOperation = function rejectReadAsyncOperation() {\n  let previousAsyncOperation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialReadAsyncOperation;\n  let fieldsToAdd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _objectSpread({}, previousAsyncOperation, {\n    fetchStatus: _constants.FETCH_STATUS.FAILED,\n    lastFetchStatusTime: Date.now(),\n    lastFetchFailed: true\n  }, fieldsToAdd);\n};\n\nexports.rejectReadAsyncOperation = rejectReadAsyncOperation;\n\nconst rejectWriteAsyncOperation = function rejectWriteAsyncOperation(previousAsyncOperation) {\n  let fieldsToAdd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _objectSpread({}, previousAsyncOperation, {\n    fetchStatus: _constants.FETCH_STATUS.FAILED,\n    lastFetchStatusTime: Date.now()\n  }, fieldsToAdd);\n};\n\nexports.rejectWriteAsyncOperation = rejectWriteAsyncOperation;\n\nconst getActionForAsyncOperation = function getActionForAsyncOperation(operation, configContainer) {\n  let extraParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  // We're going to pull out all the fields we recognize -- for both Read and Write operations --\n  // and anything left over is assumed to be part of the action (i.e., any necessary IDs or params)\n  const fetchStatus = operation.fetchStatus,\n        dataStatus = operation.dataStatus,\n        message = operation.message,\n        lastFetchStatusTime = operation.lastFetchStatusTime,\n        lastDataStatusTime = operation.lastDataStatusTime,\n        descriptorId = operation.descriptorId,\n        otherProps = _objectWithoutProperties(operation, [\"fetchStatus\", \"dataStatus\", \"message\", \"lastFetchStatusTime\", \"lastDataStatusTime\", \"descriptorId\"]);\n\n  if (!descriptorId) {\n    console.warn('AsyncOperation needs to include descriptorId so that we can re-dispatch it.', operation);\n  }\n\n  return _objectSpread({\n    type: descriptorId,\n    configContainer\n  }, otherProps, extraParams);\n};\n\nexports.getActionForAsyncOperation = getActionForAsyncOperation;"]}