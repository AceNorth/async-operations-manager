6e41dafe47a305aa0765f2351ac049a4
"use strict";

require("core-js/modules/web.dom.iterable");

var _chai = require("chai");

var _asyncOperationManagerUtils = require("../asyncOperationManagerUtils");

/* eslint-env jest */
describe('asyncOperationManagerUtils', () => {
  let state;
  beforeEach(() => {
    state = {};
  });
  describe('registerAsyncOperationDescriptors', () => {
    it('should accept object argument to register one async operation decriptor to state', () => {
      (0, _asyncOperationManagerUtils.registerAsyncOperationDescriptors)({
        descriptorId: 'FETCH_ALL_BEVERAGES_FOR_ORG',
        requiredParams: ['orgId'],
        operationType: 'READ'
      });
      const registeredAsyncDescriptors = (0, _asyncOperationManagerUtils.getRegisteredAsyncDescriptors)(state);
      (0, _chai.expect)(Object.keys(registeredAsyncDescriptors)).to.have.lengthOf(1);
      (0, _chai.expect)(registeredAsyncDescriptors).to.have.all.keys('FETCH_ALL_BEVERAGES_FOR_ORG');
    });
    it('should accept array argument to register multiple async operation descriptors to state', () => {
      (0, _asyncOperationManagerUtils.registerAsyncOperationDescriptors)([{
        descriptorId: 'FETCH_ALL_BEVERAGES_FOR_ORG',
        requiredParams: ['orgId'],
        operationType: 'READ'
      }, {
        descriptorId: 'DRINK_BEVERAGE_BY_ID_FOR_ORG',
        requiredParams: ['orgId', 'beverageId'],
        operationType: 'WRITE'
      }]);
      const registeredAsyncDescriptors = (0, _asyncOperationManagerUtils.getRegisteredAsyncDescriptors)(state);
      (0, _chai.expect)(Object.keys(registeredAsyncDescriptors)).to.have.lengthOf(2);
      (0, _chai.expect)(registeredAsyncDescriptors).to.have.all.keys('FETCH_ALL_BEVERAGES_FOR_ORG', 'DRINK_BEVERAGE_BY_ID_FOR_ORG');
    });
  });
  describe('getAsyncOperationDescriptor', () => {
    it('should successfully return a registered asyncOperationDescriptor', () => {
      (0, _asyncOperationManagerUtils.registerAsyncOperationDescriptors)({
        descriptorId: 'FETCH_PERSON_DATA_BY_ID',
        requiredParams: ['personId'],
        operationType: 'READ',
        // optional values
        parentAsyncOperation: 'FETCH_ALL_PERSON_DATA',
        debug: false,
        alwaysImmutable: false,
        minCacheTime: 5000,
        maxCacheTime: 60000
      });
      const asyncOperationDescriptor = (0, _asyncOperationManagerUtils.getAsyncOperationDescriptor)('FETCH_PERSON_DATA_BY_ID');
      (0, _chai.expect)(asyncOperationDescriptor).to.be.an('object');
      (0, _chai.expect)(asyncOperationDescriptor).to.matchSnapshot('well formed async operation descriptor');
    });
  });
  describe('getStateForOperationAfterStep', () => {
    beforeEach(() => {
      const dateNowStub = jest.fn(() => 1530518207007);
      global.Date.now = dateNowStub;
    });
    describe('READ async operations', () => {
      it('should update state to read show async operation as pending state from initial state', () => {
        (0, _asyncOperationManagerUtils.registerAsyncOperationDescriptors)({
          descriptorId: 'FETCH_PERSON_DATA',
          requiredParams: ['personId'],
          operationType: 'READ'
        });
        const transformedState = (0, _asyncOperationManagerUtils.getStateForOperationAfterStep)(state, 'BEGIN_ASYNC_OPERATION', 'FETCH_PERSON_DATA', {
          personId: 111
        });
        (0, _chai.expect)(transformedState).to.nested.include({
          'FETCH_PERSON_DATA_111.fetchStatus': 'PENDING'
        });
        (0, _chai.expect)(transformedState).to.matchSnapshot('updated state showing begun read async operation');
      });
      it('should update state to read show async operation as successful state from pending state', () => {
        state = {
          FETCH_PERSON_DATA_111: {
            descriptorId: 'FETCH_PERSON_DATA',
            fetchStatus: 'PENDING',
            dataStatus: 'ABSENT',
            message: null,
            lastFetchStatusTime: 0,
            lastDataStatusTime: 0,
            personId: 111
          }
        };
        (0, _asyncOperationManagerUtils.registerAsyncOperationDescriptors)({
          descriptorId: 'FETCH_PERSON_DATA',
          requiredParams: ['personId'],
          operationType: 'READ'
        });
        const transformedState = (0, _asyncOperationManagerUtils.getStateForOperationAfterStep)(state, 'RESOLVE_ASYNC_OPERATION', 'FETCH_PERSON_DATA', {
          personId: 111
        });
        (0, _chai.expect)(transformedState).to.nested.include({
          'FETCH_PERSON_DATA_111.fetchStatus': 'SUCCESSFUL'
        });
        (0, _chai.expect)(transformedState).to.matchSnapshot('updated state showing successful read async operation');
      });
      it('should update state to read show async operation as failed state from pending state', () => {
        state = {
          FETCH_PERSON_DATA_111: {
            descriptorId: 'FETCH_PERSON_DATA',
            fetchStatus: 'PENDING',
            dataStatus: 'ABSENT',
            message: null,
            lastFetchStatusTime: 0,
            lastDataStatusTime: 0,
            personId: 111
          }
        };
        (0, _asyncOperationManagerUtils.registerAsyncOperationDescriptors)({
          descriptorId: 'FETCH_PERSON_DATA',
          requiredParams: ['personId'],
          operationType: 'READ'
        });
        const transformedState = (0, _asyncOperationManagerUtils.getStateForOperationAfterStep)(state, 'REJECT_ASYNC_OPERATION', 'FETCH_PERSON_DATA', {
          personId: 111
        });
        (0, _chai.expect)(transformedState).to.nested.include({
          'FETCH_PERSON_DATA_111.fetchStatus': 'FAILED'
        });
        (0, _chai.expect)(transformedState).to.matchSnapshot('updated state showing rejected async operation');
      });
    });
    describe('WRITE async operations', () => {
      it('should update state to show write async operation as pending state from initial state', () => {
        (0, _asyncOperationManagerUtils.registerAsyncOperationDescriptors)({
          descriptorId: 'UPDATE_PERSON_DATA',
          requiredParams: ['personId'],
          operationType: 'WRITE'
        });
        const transformedState = (0, _asyncOperationManagerUtils.getStateForOperationAfterStep)(state, 'BEGIN_ASYNC_OPERATION', 'UPDATE_PERSON_DATA', {
          personId: 111
        });
        (0, _chai.expect)(transformedState).to.nested.include({
          'UPDATE_PERSON_DATA_111.fetchStatus': 'PENDING'
        });
        (0, _chai.expect)(transformedState).to.matchSnapshot('updated state showing pending write async operation');
      });
      it('should update state to show write async operation as successful state from pending state', () => {
        state = {
          UPDATE_PERSON_DATA_111: {
            descriptorId: 'UPDATE_PERSON_DATA',
            fetchStatus: 'PENDING',
            message: null,
            lastFetchStatusTime: 0,
            lastDataStatusTime: 0,
            personId: 111
          }
        };
        (0, _asyncOperationManagerUtils.registerAsyncOperationDescriptors)({
          descriptorId: 'UPDATE_PERSON_DATA',
          requiredParams: ['personId'],
          operationType: 'WRITE'
        });
        const transformedState = (0, _asyncOperationManagerUtils.getStateForOperationAfterStep)(state, 'RESOLVE_ASYNC_OPERATION', 'UPDATE_PERSON_DATA', {
          personId: 111
        });
        (0, _chai.expect)(transformedState).to.nested.include({
          'UPDATE_PERSON_DATA_111.fetchStatus': 'SUCCESSFUL'
        });
        (0, _chai.expect)(transformedState).to.matchSnapshot('updated state showing successful write async operation');
      });
      it('should update state to show write async operation as failed state from pending state', () => {
        state = {
          UPDATE_PERSON_DATA_111: {
            descriptorId: 'UPDATE_PERSON_DATA',
            fetchStatus: 'PENDING',
            message: null,
            lastFetchStatusTime: 0,
            lastDataStatusTime: 0,
            personId: 111
          }
        };
        (0, _asyncOperationManagerUtils.registerAsyncOperationDescriptors)({
          descriptorId: 'UPDATE_PERSON_DATA',
          requiredParams: ['personId'],
          operationType: 'WRITE'
        });
        const transformedState = (0, _asyncOperationManagerUtils.getStateForOperationAfterStep)(state, 'REJECT_ASYNC_OPERATION', 'UPDATE_PERSON_DATA', {
          personId: 111
        });
        (0, _chai.expect)(transformedState).to.nested.include({
          'UPDATE_PERSON_DATA_111.fetchStatus': 'FAILED'
        });
        (0, _chai.expect)(transformedState).to.matchSnapshot('updated state showing failed write async operation');
      });
    });
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzeW5jT3BlcmF0aW9uTWFuYWdlclV0aWxzX3Rlc3QuanMiXSwibmFtZXMiOlsicmVxdWlyZSIsIl9jaGFpIiwiX2FzeW5jT3BlcmF0aW9uTWFuYWdlclV0aWxzIiwiZGVzY3JpYmUiLCJzdGF0ZSIsImJlZm9yZUVhY2giLCJpdCIsInJlZ2lzdGVyQXN5bmNPcGVyYXRpb25EZXNjcmlwdG9ycyIsImRlc2NyaXB0b3JJZCIsInJlcXVpcmVkUGFyYW1zIiwib3BlcmF0aW9uVHlwZSIsInJlZ2lzdGVyZWRBc3luY0Rlc2NyaXB0b3JzIiwiZ2V0UmVnaXN0ZXJlZEFzeW5jRGVzY3JpcHRvcnMiLCJleHBlY3QiLCJPYmplY3QiLCJrZXlzIiwidG8iLCJoYXZlIiwibGVuZ3RoT2YiLCJhbGwiLCJwYXJlbnRBc3luY09wZXJhdGlvbiIsImRlYnVnIiwiYWx3YXlzSW1tdXRhYmxlIiwibWluQ2FjaGVUaW1lIiwibWF4Q2FjaGVUaW1lIiwiYXN5bmNPcGVyYXRpb25EZXNjcmlwdG9yIiwiZ2V0QXN5bmNPcGVyYXRpb25EZXNjcmlwdG9yIiwiYmUiLCJhbiIsIm1hdGNoU25hcHNob3QiLCJkYXRlTm93U3R1YiIsImplc3QiLCJmbiIsImdsb2JhbCIsIkRhdGUiLCJub3ciLCJ0cmFuc2Zvcm1lZFN0YXRlIiwiZ2V0U3RhdGVGb3JPcGVyYXRpb25BZnRlclN0ZXAiLCJwZXJzb25JZCIsIm5lc3RlZCIsImluY2x1ZGUiLCJGRVRDSF9QRVJTT05fREFUQV8xMTEiLCJmZXRjaFN0YXR1cyIsImRhdGFTdGF0dXMiLCJtZXNzYWdlIiwibGFzdEZldGNoU3RhdHVzVGltZSIsImxhc3REYXRhU3RhdHVzVGltZSIsIlVQREFURV9QRVJTT05fREFUQV8xMTEiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBQSxRQUFRLGtDQUFSOztBQUVBLElBQUlDLFFBQVFELFFBQVEsTUFBUixDQUFaOztBQUVBLElBQUlFLDhCQUE4QkYsUUFBUSwrQkFBUixDQUFsQzs7QUFFQTtBQUNBRyxTQUFTLDRCQUFULEVBQXVDLE1BQU07QUFDM0MsTUFBSUMsS0FBSjtBQUNBQyxhQUFXLE1BQU07QUFDZkQsWUFBUSxFQUFSO0FBQ0QsR0FGRDtBQUdBRCxXQUFTLG1DQUFULEVBQThDLE1BQU07QUFDbERHLE9BQUcsa0ZBQUgsRUFBdUYsTUFBTTtBQUMzRixPQUFDLEdBQUdKLDRCQUE0QkssaUNBQWhDLEVBQW1FO0FBQ2pFQyxzQkFBYyw2QkFEbUQ7QUFFakVDLHdCQUFnQixDQUFDLE9BQUQsQ0FGaUQ7QUFHakVDLHVCQUFlO0FBSGtELE9BQW5FO0FBS0EsWUFBTUMsNkJBQTZCLENBQUMsR0FBR1QsNEJBQTRCVSw2QkFBaEMsRUFBK0RSLEtBQS9ELENBQW5DO0FBQ0EsT0FBQyxHQUFHSCxNQUFNWSxNQUFWLEVBQWtCQyxPQUFPQyxJQUFQLENBQVlKLDBCQUFaLENBQWxCLEVBQTJESyxFQUEzRCxDQUE4REMsSUFBOUQsQ0FBbUVDLFFBQW5FLENBQTRFLENBQTVFO0FBQ0EsT0FBQyxHQUFHakIsTUFBTVksTUFBVixFQUFrQkYsMEJBQWxCLEVBQThDSyxFQUE5QyxDQUFpREMsSUFBakQsQ0FBc0RFLEdBQXRELENBQTBESixJQUExRCxDQUErRCw2QkFBL0Q7QUFDRCxLQVREO0FBVUFULE9BQUcsd0ZBQUgsRUFBNkYsTUFBTTtBQUNqRyxPQUFDLEdBQUdKLDRCQUE0QkssaUNBQWhDLEVBQW1FLENBQUM7QUFDbEVDLHNCQUFjLDZCQURvRDtBQUVsRUMsd0JBQWdCLENBQUMsT0FBRCxDQUZrRDtBQUdsRUMsdUJBQWU7QUFIbUQsT0FBRCxFQUloRTtBQUNERixzQkFBYyw4QkFEYjtBQUVEQyx3QkFBZ0IsQ0FBQyxPQUFELEVBQVUsWUFBVixDQUZmO0FBR0RDLHVCQUFlO0FBSGQsT0FKZ0UsQ0FBbkU7QUFTQSxZQUFNQyw2QkFBNkIsQ0FBQyxHQUFHVCw0QkFBNEJVLDZCQUFoQyxFQUErRFIsS0FBL0QsQ0FBbkM7QUFDQSxPQUFDLEdBQUdILE1BQU1ZLE1BQVYsRUFBa0JDLE9BQU9DLElBQVAsQ0FBWUosMEJBQVosQ0FBbEIsRUFBMkRLLEVBQTNELENBQThEQyxJQUE5RCxDQUFtRUMsUUFBbkUsQ0FBNEUsQ0FBNUU7QUFDQSxPQUFDLEdBQUdqQixNQUFNWSxNQUFWLEVBQWtCRiwwQkFBbEIsRUFBOENLLEVBQTlDLENBQWlEQyxJQUFqRCxDQUFzREUsR0FBdEQsQ0FBMERKLElBQTFELENBQStELDZCQUEvRCxFQUE4Riw4QkFBOUY7QUFDRCxLQWJEO0FBY0QsR0F6QkQ7QUEwQkFaLFdBQVMsNkJBQVQsRUFBd0MsTUFBTTtBQUM1Q0csT0FBRyxrRUFBSCxFQUF1RSxNQUFNO0FBQzNFLE9BQUMsR0FBR0osNEJBQTRCSyxpQ0FBaEMsRUFBbUU7QUFDakVDLHNCQUFjLHlCQURtRDtBQUVqRUMsd0JBQWdCLENBQUMsVUFBRCxDQUZpRDtBQUdqRUMsdUJBQWUsTUFIa0Q7QUFJakU7QUFDQVUsOEJBQXNCLHVCQUwyQztBQU1qRUMsZUFBTyxLQU4wRDtBQU9qRUMseUJBQWlCLEtBUGdEO0FBUWpFQyxzQkFBYyxJQVJtRDtBQVNqRUMsc0JBQWM7QUFUbUQsT0FBbkU7QUFXQSxZQUFNQywyQkFBMkIsQ0FBQyxHQUFHdkIsNEJBQTRCd0IsMkJBQWhDLEVBQTZELHlCQUE3RCxDQUFqQztBQUNBLE9BQUMsR0FBR3pCLE1BQU1ZLE1BQVYsRUFBa0JZLHdCQUFsQixFQUE0Q1QsRUFBNUMsQ0FBK0NXLEVBQS9DLENBQWtEQyxFQUFsRCxDQUFxRCxRQUFyRDtBQUNBLE9BQUMsR0FBRzNCLE1BQU1ZLE1BQVYsRUFBa0JZLHdCQUFsQixFQUE0Q1QsRUFBNUMsQ0FBK0NhLGFBQS9DLENBQTZELHdDQUE3RDtBQUNELEtBZkQ7QUFnQkQsR0FqQkQ7QUFrQkExQixXQUFTLCtCQUFULEVBQTBDLE1BQU07QUFDOUNFLGVBQVcsTUFBTTtBQUNmLFlBQU15QixjQUFjQyxLQUFLQyxFQUFMLENBQVEsTUFBTSxhQUFkLENBQXBCO0FBQ0FDLGFBQU9DLElBQVAsQ0FBWUMsR0FBWixHQUFrQkwsV0FBbEI7QUFDRCxLQUhEO0FBSUEzQixhQUFTLHVCQUFULEVBQWtDLE1BQU07QUFDdENHLFNBQUcsc0ZBQUgsRUFBMkYsTUFBTTtBQUMvRixTQUFDLEdBQUdKLDRCQUE0QkssaUNBQWhDLEVBQW1FO0FBQ2pFQyx3QkFBYyxtQkFEbUQ7QUFFakVDLDBCQUFnQixDQUFDLFVBQUQsQ0FGaUQ7QUFHakVDLHlCQUFlO0FBSGtELFNBQW5FO0FBS0EsY0FBTTBCLG1CQUFtQixDQUFDLEdBQUdsQyw0QkFBNEJtQyw2QkFBaEMsRUFBK0RqQyxLQUEvRCxFQUFzRSx1QkFBdEUsRUFBK0YsbUJBQS9GLEVBQW9IO0FBQzNJa0Msb0JBQVU7QUFEaUksU0FBcEgsQ0FBekI7QUFHQSxTQUFDLEdBQUdyQyxNQUFNWSxNQUFWLEVBQWtCdUIsZ0JBQWxCLEVBQW9DcEIsRUFBcEMsQ0FBdUN1QixNQUF2QyxDQUE4Q0MsT0FBOUMsQ0FBc0Q7QUFDcEQsK0NBQXFDO0FBRGUsU0FBdEQ7QUFHQSxTQUFDLEdBQUd2QyxNQUFNWSxNQUFWLEVBQWtCdUIsZ0JBQWxCLEVBQW9DcEIsRUFBcEMsQ0FBdUNhLGFBQXZDLENBQXFELGtEQUFyRDtBQUNELE9BYkQ7QUFjQXZCLFNBQUcseUZBQUgsRUFBOEYsTUFBTTtBQUNsR0YsZ0JBQVE7QUFDTnFDLGlDQUF1QjtBQUNyQmpDLDBCQUFjLG1CQURPO0FBRXJCa0MseUJBQWEsU0FGUTtBQUdyQkMsd0JBQVksUUFIUztBQUlyQkMscUJBQVMsSUFKWTtBQUtyQkMsaUNBQXFCLENBTEE7QUFNckJDLGdDQUFvQixDQU5DO0FBT3JCUixzQkFBVTtBQVBXO0FBRGpCLFNBQVI7QUFXQSxTQUFDLEdBQUdwQyw0QkFBNEJLLGlDQUFoQyxFQUFtRTtBQUNqRUMsd0JBQWMsbUJBRG1EO0FBRWpFQywwQkFBZ0IsQ0FBQyxVQUFELENBRmlEO0FBR2pFQyx5QkFBZTtBQUhrRCxTQUFuRTtBQUtBLGNBQU0wQixtQkFBbUIsQ0FBQyxHQUFHbEMsNEJBQTRCbUMsNkJBQWhDLEVBQStEakMsS0FBL0QsRUFBc0UseUJBQXRFLEVBQWlHLG1CQUFqRyxFQUFzSDtBQUM3SWtDLG9CQUFVO0FBRG1JLFNBQXRILENBQXpCO0FBR0EsU0FBQyxHQUFHckMsTUFBTVksTUFBVixFQUFrQnVCLGdCQUFsQixFQUFvQ3BCLEVBQXBDLENBQXVDdUIsTUFBdkMsQ0FBOENDLE9BQTlDLENBQXNEO0FBQ3BELCtDQUFxQztBQURlLFNBQXREO0FBR0EsU0FBQyxHQUFHdkMsTUFBTVksTUFBVixFQUFrQnVCLGdCQUFsQixFQUFvQ3BCLEVBQXBDLENBQXVDYSxhQUF2QyxDQUFxRCx1REFBckQ7QUFDRCxPQXhCRDtBQXlCQXZCLFNBQUcscUZBQUgsRUFBMEYsTUFBTTtBQUM5RkYsZ0JBQVE7QUFDTnFDLGlDQUF1QjtBQUNyQmpDLDBCQUFjLG1CQURPO0FBRXJCa0MseUJBQWEsU0FGUTtBQUdyQkMsd0JBQVksUUFIUztBQUlyQkMscUJBQVMsSUFKWTtBQUtyQkMsaUNBQXFCLENBTEE7QUFNckJDLGdDQUFvQixDQU5DO0FBT3JCUixzQkFBVTtBQVBXO0FBRGpCLFNBQVI7QUFXQSxTQUFDLEdBQUdwQyw0QkFBNEJLLGlDQUFoQyxFQUFtRTtBQUNqRUMsd0JBQWMsbUJBRG1EO0FBRWpFQywwQkFBZ0IsQ0FBQyxVQUFELENBRmlEO0FBR2pFQyx5QkFBZTtBQUhrRCxTQUFuRTtBQUtBLGNBQU0wQixtQkFBbUIsQ0FBQyxHQUFHbEMsNEJBQTRCbUMsNkJBQWhDLEVBQStEakMsS0FBL0QsRUFBc0Usd0JBQXRFLEVBQWdHLG1CQUFoRyxFQUFxSDtBQUM1SWtDLG9CQUFVO0FBRGtJLFNBQXJILENBQXpCO0FBR0EsU0FBQyxHQUFHckMsTUFBTVksTUFBVixFQUFrQnVCLGdCQUFsQixFQUFvQ3BCLEVBQXBDLENBQXVDdUIsTUFBdkMsQ0FBOENDLE9BQTlDLENBQXNEO0FBQ3BELCtDQUFxQztBQURlLFNBQXREO0FBR0EsU0FBQyxHQUFHdkMsTUFBTVksTUFBVixFQUFrQnVCLGdCQUFsQixFQUFvQ3BCLEVBQXBDLENBQXVDYSxhQUF2QyxDQUFxRCxnREFBckQ7QUFDRCxPQXhCRDtBQXlCRCxLQWpFRDtBQWtFQTFCLGFBQVMsd0JBQVQsRUFBbUMsTUFBTTtBQUN2Q0csU0FBRyx1RkFBSCxFQUE0RixNQUFNO0FBQ2hHLFNBQUMsR0FBR0osNEJBQTRCSyxpQ0FBaEMsRUFBbUU7QUFDakVDLHdCQUFjLG9CQURtRDtBQUVqRUMsMEJBQWdCLENBQUMsVUFBRCxDQUZpRDtBQUdqRUMseUJBQWU7QUFIa0QsU0FBbkU7QUFLQSxjQUFNMEIsbUJBQW1CLENBQUMsR0FBR2xDLDRCQUE0Qm1DLDZCQUFoQyxFQUErRGpDLEtBQS9ELEVBQXNFLHVCQUF0RSxFQUErRixvQkFBL0YsRUFBcUg7QUFDNUlrQyxvQkFBVTtBQURrSSxTQUFySCxDQUF6QjtBQUdBLFNBQUMsR0FBR3JDLE1BQU1ZLE1BQVYsRUFBa0J1QixnQkFBbEIsRUFBb0NwQixFQUFwQyxDQUF1Q3VCLE1BQXZDLENBQThDQyxPQUE5QyxDQUFzRDtBQUNwRCxnREFBc0M7QUFEYyxTQUF0RDtBQUdBLFNBQUMsR0FBR3ZDLE1BQU1ZLE1BQVYsRUFBa0J1QixnQkFBbEIsRUFBb0NwQixFQUFwQyxDQUF1Q2EsYUFBdkMsQ0FBcUQscURBQXJEO0FBQ0QsT0FiRDtBQWNBdkIsU0FBRywwRkFBSCxFQUErRixNQUFNO0FBQ25HRixnQkFBUTtBQUNOMkMsa0NBQXdCO0FBQ3RCdkMsMEJBQWMsb0JBRFE7QUFFdEJrQyx5QkFBYSxTQUZTO0FBR3RCRSxxQkFBUyxJQUhhO0FBSXRCQyxpQ0FBcUIsQ0FKQztBQUt0QkMsZ0NBQW9CLENBTEU7QUFNdEJSLHNCQUFVO0FBTlk7QUFEbEIsU0FBUjtBQVVBLFNBQUMsR0FBR3BDLDRCQUE0QkssaUNBQWhDLEVBQW1FO0FBQ2pFQyx3QkFBYyxvQkFEbUQ7QUFFakVDLDBCQUFnQixDQUFDLFVBQUQsQ0FGaUQ7QUFHakVDLHlCQUFlO0FBSGtELFNBQW5FO0FBS0EsY0FBTTBCLG1CQUFtQixDQUFDLEdBQUdsQyw0QkFBNEJtQyw2QkFBaEMsRUFBK0RqQyxLQUEvRCxFQUFzRSx5QkFBdEUsRUFBaUcsb0JBQWpHLEVBQXVIO0FBQzlJa0Msb0JBQVU7QUFEb0ksU0FBdkgsQ0FBekI7QUFHQSxTQUFDLEdBQUdyQyxNQUFNWSxNQUFWLEVBQWtCdUIsZ0JBQWxCLEVBQW9DcEIsRUFBcEMsQ0FBdUN1QixNQUF2QyxDQUE4Q0MsT0FBOUMsQ0FBc0Q7QUFDcEQsZ0RBQXNDO0FBRGMsU0FBdEQ7QUFHQSxTQUFDLEdBQUd2QyxNQUFNWSxNQUFWLEVBQWtCdUIsZ0JBQWxCLEVBQW9DcEIsRUFBcEMsQ0FBdUNhLGFBQXZDLENBQXFELHdEQUFyRDtBQUNELE9BdkJEO0FBd0JBdkIsU0FBRyxzRkFBSCxFQUEyRixNQUFNO0FBQy9GRixnQkFBUTtBQUNOMkMsa0NBQXdCO0FBQ3RCdkMsMEJBQWMsb0JBRFE7QUFFdEJrQyx5QkFBYSxTQUZTO0FBR3RCRSxxQkFBUyxJQUhhO0FBSXRCQyxpQ0FBcUIsQ0FKQztBQUt0QkMsZ0NBQW9CLENBTEU7QUFNdEJSLHNCQUFVO0FBTlk7QUFEbEIsU0FBUjtBQVVBLFNBQUMsR0FBR3BDLDRCQUE0QkssaUNBQWhDLEVBQW1FO0FBQ2pFQyx3QkFBYyxvQkFEbUQ7QUFFakVDLDBCQUFnQixDQUFDLFVBQUQsQ0FGaUQ7QUFHakVDLHlCQUFlO0FBSGtELFNBQW5FO0FBS0EsY0FBTTBCLG1CQUFtQixDQUFDLEdBQUdsQyw0QkFBNEJtQyw2QkFBaEMsRUFBK0RqQyxLQUEvRCxFQUFzRSx3QkFBdEUsRUFBZ0csb0JBQWhHLEVBQXNIO0FBQzdJa0Msb0JBQVU7QUFEbUksU0FBdEgsQ0FBekI7QUFHQSxTQUFDLEdBQUdyQyxNQUFNWSxNQUFWLEVBQWtCdUIsZ0JBQWxCLEVBQW9DcEIsRUFBcEMsQ0FBdUN1QixNQUF2QyxDQUE4Q0MsT0FBOUMsQ0FBc0Q7QUFDcEQsZ0RBQXNDO0FBRGMsU0FBdEQ7QUFHQSxTQUFDLEdBQUd2QyxNQUFNWSxNQUFWLEVBQWtCdUIsZ0JBQWxCLEVBQW9DcEIsRUFBcEMsQ0FBdUNhLGFBQXZDLENBQXFELG9EQUFyRDtBQUNELE9BdkJEO0FBd0JELEtBL0REO0FBZ0VELEdBdklEO0FBd0lELENBekxEIiwiZmlsZSI6ImFzeW5jT3BlcmF0aW9uTWFuYWdlclV0aWxzX3Rlc3QuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlXCIpO1xuXG52YXIgX2NoYWkgPSByZXF1aXJlKFwiY2hhaVwiKTtcblxudmFyIF9hc3luY09wZXJhdGlvbk1hbmFnZXJVdGlscyA9IHJlcXVpcmUoXCIuLi9hc3luY09wZXJhdGlvbk1hbmFnZXJVdGlsc1wiKTtcblxuLyogZXNsaW50LWVudiBqZXN0ICovXG5kZXNjcmliZSgnYXN5bmNPcGVyYXRpb25NYW5hZ2VyVXRpbHMnLCAoKSA9PiB7XG4gIGxldCBzdGF0ZTtcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgc3RhdGUgPSB7fTtcbiAgfSk7XG4gIGRlc2NyaWJlKCdyZWdpc3RlckFzeW5jT3BlcmF0aW9uRGVzY3JpcHRvcnMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBhY2NlcHQgb2JqZWN0IGFyZ3VtZW50IHRvIHJlZ2lzdGVyIG9uZSBhc3luYyBvcGVyYXRpb24gZGVjcmlwdG9yIHRvIHN0YXRlJywgKCkgPT4ge1xuICAgICAgKDAsIF9hc3luY09wZXJhdGlvbk1hbmFnZXJVdGlscy5yZWdpc3RlckFzeW5jT3BlcmF0aW9uRGVzY3JpcHRvcnMpKHtcbiAgICAgICAgZGVzY3JpcHRvcklkOiAnRkVUQ0hfQUxMX0JFVkVSQUdFU19GT1JfT1JHJyxcbiAgICAgICAgcmVxdWlyZWRQYXJhbXM6IFsnb3JnSWQnXSxcbiAgICAgICAgb3BlcmF0aW9uVHlwZTogJ1JFQUQnXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlZ2lzdGVyZWRBc3luY0Rlc2NyaXB0b3JzID0gKDAsIF9hc3luY09wZXJhdGlvbk1hbmFnZXJVdGlscy5nZXRSZWdpc3RlcmVkQXN5bmNEZXNjcmlwdG9ycykoc3RhdGUpO1xuICAgICAgKDAsIF9jaGFpLmV4cGVjdCkoT2JqZWN0LmtleXMocmVnaXN0ZXJlZEFzeW5jRGVzY3JpcHRvcnMpKS50by5oYXZlLmxlbmd0aE9mKDEpO1xuICAgICAgKDAsIF9jaGFpLmV4cGVjdCkocmVnaXN0ZXJlZEFzeW5jRGVzY3JpcHRvcnMpLnRvLmhhdmUuYWxsLmtleXMoJ0ZFVENIX0FMTF9CRVZFUkFHRVNfRk9SX09SRycpO1xuICAgIH0pO1xuICAgIGl0KCdzaG91bGQgYWNjZXB0IGFycmF5IGFyZ3VtZW50IHRvIHJlZ2lzdGVyIG11bHRpcGxlIGFzeW5jIG9wZXJhdGlvbiBkZXNjcmlwdG9ycyB0byBzdGF0ZScsICgpID0+IHtcbiAgICAgICgwLCBfYXN5bmNPcGVyYXRpb25NYW5hZ2VyVXRpbHMucmVnaXN0ZXJBc3luY09wZXJhdGlvbkRlc2NyaXB0b3JzKShbe1xuICAgICAgICBkZXNjcmlwdG9ySWQ6ICdGRVRDSF9BTExfQkVWRVJBR0VTX0ZPUl9PUkcnLFxuICAgICAgICByZXF1aXJlZFBhcmFtczogWydvcmdJZCddLFxuICAgICAgICBvcGVyYXRpb25UeXBlOiAnUkVBRCdcbiAgICAgIH0sIHtcbiAgICAgICAgZGVzY3JpcHRvcklkOiAnRFJJTktfQkVWRVJBR0VfQllfSURfRk9SX09SRycsXG4gICAgICAgIHJlcXVpcmVkUGFyYW1zOiBbJ29yZ0lkJywgJ2JldmVyYWdlSWQnXSxcbiAgICAgICAgb3BlcmF0aW9uVHlwZTogJ1dSSVRFJ1xuICAgICAgfV0pO1xuICAgICAgY29uc3QgcmVnaXN0ZXJlZEFzeW5jRGVzY3JpcHRvcnMgPSAoMCwgX2FzeW5jT3BlcmF0aW9uTWFuYWdlclV0aWxzLmdldFJlZ2lzdGVyZWRBc3luY0Rlc2NyaXB0b3JzKShzdGF0ZSk7XG4gICAgICAoMCwgX2NoYWkuZXhwZWN0KShPYmplY3Qua2V5cyhyZWdpc3RlcmVkQXN5bmNEZXNjcmlwdG9ycykpLnRvLmhhdmUubGVuZ3RoT2YoMik7XG4gICAgICAoMCwgX2NoYWkuZXhwZWN0KShyZWdpc3RlcmVkQXN5bmNEZXNjcmlwdG9ycykudG8uaGF2ZS5hbGwua2V5cygnRkVUQ0hfQUxMX0JFVkVSQUdFU19GT1JfT1JHJywgJ0RSSU5LX0JFVkVSQUdFX0JZX0lEX0ZPUl9PUkcnKTtcbiAgICB9KTtcbiAgfSk7XG4gIGRlc2NyaWJlKCdnZXRBc3luY09wZXJhdGlvbkRlc2NyaXB0b3InLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBzdWNjZXNzZnVsbHkgcmV0dXJuIGEgcmVnaXN0ZXJlZCBhc3luY09wZXJhdGlvbkRlc2NyaXB0b3InLCAoKSA9PiB7XG4gICAgICAoMCwgX2FzeW5jT3BlcmF0aW9uTWFuYWdlclV0aWxzLnJlZ2lzdGVyQXN5bmNPcGVyYXRpb25EZXNjcmlwdG9ycykoe1xuICAgICAgICBkZXNjcmlwdG9ySWQ6ICdGRVRDSF9QRVJTT05fREFUQV9CWV9JRCcsXG4gICAgICAgIHJlcXVpcmVkUGFyYW1zOiBbJ3BlcnNvbklkJ10sXG4gICAgICAgIG9wZXJhdGlvblR5cGU6ICdSRUFEJyxcbiAgICAgICAgLy8gb3B0aW9uYWwgdmFsdWVzXG4gICAgICAgIHBhcmVudEFzeW5jT3BlcmF0aW9uOiAnRkVUQ0hfQUxMX1BFUlNPTl9EQVRBJyxcbiAgICAgICAgZGVidWc6IGZhbHNlLFxuICAgICAgICBhbHdheXNJbW11dGFibGU6IGZhbHNlLFxuICAgICAgICBtaW5DYWNoZVRpbWU6IDUwMDAsXG4gICAgICAgIG1heENhY2hlVGltZTogNjAwMDBcbiAgICAgIH0pO1xuICAgICAgY29uc3QgYXN5bmNPcGVyYXRpb25EZXNjcmlwdG9yID0gKDAsIF9hc3luY09wZXJhdGlvbk1hbmFnZXJVdGlscy5nZXRBc3luY09wZXJhdGlvbkRlc2NyaXB0b3IpKCdGRVRDSF9QRVJTT05fREFUQV9CWV9JRCcpO1xuICAgICAgKDAsIF9jaGFpLmV4cGVjdCkoYXN5bmNPcGVyYXRpb25EZXNjcmlwdG9yKS50by5iZS5hbignb2JqZWN0Jyk7XG4gICAgICAoMCwgX2NoYWkuZXhwZWN0KShhc3luY09wZXJhdGlvbkRlc2NyaXB0b3IpLnRvLm1hdGNoU25hcHNob3QoJ3dlbGwgZm9ybWVkIGFzeW5jIG9wZXJhdGlvbiBkZXNjcmlwdG9yJyk7XG4gICAgfSk7XG4gIH0pO1xuICBkZXNjcmliZSgnZ2V0U3RhdGVGb3JPcGVyYXRpb25BZnRlclN0ZXAnLCAoKSA9PiB7XG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICBjb25zdCBkYXRlTm93U3R1YiA9IGplc3QuZm4oKCkgPT4gMTUzMDUxODIwNzAwNyk7XG4gICAgICBnbG9iYWwuRGF0ZS5ub3cgPSBkYXRlTm93U3R1YjtcbiAgICB9KTtcbiAgICBkZXNjcmliZSgnUkVBRCBhc3luYyBvcGVyYXRpb25zJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCB1cGRhdGUgc3RhdGUgdG8gcmVhZCBzaG93IGFzeW5jIG9wZXJhdGlvbiBhcyBwZW5kaW5nIHN0YXRlIGZyb20gaW5pdGlhbCBzdGF0ZScsICgpID0+IHtcbiAgICAgICAgKDAsIF9hc3luY09wZXJhdGlvbk1hbmFnZXJVdGlscy5yZWdpc3RlckFzeW5jT3BlcmF0aW9uRGVzY3JpcHRvcnMpKHtcbiAgICAgICAgICBkZXNjcmlwdG9ySWQ6ICdGRVRDSF9QRVJTT05fREFUQScsXG4gICAgICAgICAgcmVxdWlyZWRQYXJhbXM6IFsncGVyc29uSWQnXSxcbiAgICAgICAgICBvcGVyYXRpb25UeXBlOiAnUkVBRCdcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkU3RhdGUgPSAoMCwgX2FzeW5jT3BlcmF0aW9uTWFuYWdlclV0aWxzLmdldFN0YXRlRm9yT3BlcmF0aW9uQWZ0ZXJTdGVwKShzdGF0ZSwgJ0JFR0lOX0FTWU5DX09QRVJBVElPTicsICdGRVRDSF9QRVJTT05fREFUQScsIHtcbiAgICAgICAgICBwZXJzb25JZDogMTExXG4gICAgICAgIH0pO1xuICAgICAgICAoMCwgX2NoYWkuZXhwZWN0KSh0cmFuc2Zvcm1lZFN0YXRlKS50by5uZXN0ZWQuaW5jbHVkZSh7XG4gICAgICAgICAgJ0ZFVENIX1BFUlNPTl9EQVRBXzExMS5mZXRjaFN0YXR1cyc6ICdQRU5ESU5HJ1xuICAgICAgICB9KTtcbiAgICAgICAgKDAsIF9jaGFpLmV4cGVjdCkodHJhbnNmb3JtZWRTdGF0ZSkudG8ubWF0Y2hTbmFwc2hvdCgndXBkYXRlZCBzdGF0ZSBzaG93aW5nIGJlZ3VuIHJlYWQgYXN5bmMgb3BlcmF0aW9uJyk7XG4gICAgICB9KTtcbiAgICAgIGl0KCdzaG91bGQgdXBkYXRlIHN0YXRlIHRvIHJlYWQgc2hvdyBhc3luYyBvcGVyYXRpb24gYXMgc3VjY2Vzc2Z1bCBzdGF0ZSBmcm9tIHBlbmRpbmcgc3RhdGUnLCAoKSA9PiB7XG4gICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgIEZFVENIX1BFUlNPTl9EQVRBXzExMToge1xuICAgICAgICAgICAgZGVzY3JpcHRvcklkOiAnRkVUQ0hfUEVSU09OX0RBVEEnLFxuICAgICAgICAgICAgZmV0Y2hTdGF0dXM6ICdQRU5ESU5HJyxcbiAgICAgICAgICAgIGRhdGFTdGF0dXM6ICdBQlNFTlQnLFxuICAgICAgICAgICAgbWVzc2FnZTogbnVsbCxcbiAgICAgICAgICAgIGxhc3RGZXRjaFN0YXR1c1RpbWU6IDAsXG4gICAgICAgICAgICBsYXN0RGF0YVN0YXR1c1RpbWU6IDAsXG4gICAgICAgICAgICBwZXJzb25JZDogMTExXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAoMCwgX2FzeW5jT3BlcmF0aW9uTWFuYWdlclV0aWxzLnJlZ2lzdGVyQXN5bmNPcGVyYXRpb25EZXNjcmlwdG9ycykoe1xuICAgICAgICAgIGRlc2NyaXB0b3JJZDogJ0ZFVENIX1BFUlNPTl9EQVRBJyxcbiAgICAgICAgICByZXF1aXJlZFBhcmFtczogWydwZXJzb25JZCddLFxuICAgICAgICAgIG9wZXJhdGlvblR5cGU6ICdSRUFEJ1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRTdGF0ZSA9ICgwLCBfYXN5bmNPcGVyYXRpb25NYW5hZ2VyVXRpbHMuZ2V0U3RhdGVGb3JPcGVyYXRpb25BZnRlclN0ZXApKHN0YXRlLCAnUkVTT0xWRV9BU1lOQ19PUEVSQVRJT04nLCAnRkVUQ0hfUEVSU09OX0RBVEEnLCB7XG4gICAgICAgICAgcGVyc29uSWQ6IDExMVxuICAgICAgICB9KTtcbiAgICAgICAgKDAsIF9jaGFpLmV4cGVjdCkodHJhbnNmb3JtZWRTdGF0ZSkudG8ubmVzdGVkLmluY2x1ZGUoe1xuICAgICAgICAgICdGRVRDSF9QRVJTT05fREFUQV8xMTEuZmV0Y2hTdGF0dXMnOiAnU1VDQ0VTU0ZVTCdcbiAgICAgICAgfSk7XG4gICAgICAgICgwLCBfY2hhaS5leHBlY3QpKHRyYW5zZm9ybWVkU3RhdGUpLnRvLm1hdGNoU25hcHNob3QoJ3VwZGF0ZWQgc3RhdGUgc2hvd2luZyBzdWNjZXNzZnVsIHJlYWQgYXN5bmMgb3BlcmF0aW9uJyk7XG4gICAgICB9KTtcbiAgICAgIGl0KCdzaG91bGQgdXBkYXRlIHN0YXRlIHRvIHJlYWQgc2hvdyBhc3luYyBvcGVyYXRpb24gYXMgZmFpbGVkIHN0YXRlIGZyb20gcGVuZGluZyBzdGF0ZScsICgpID0+IHtcbiAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgRkVUQ0hfUEVSU09OX0RBVEFfMTExOiB7XG4gICAgICAgICAgICBkZXNjcmlwdG9ySWQ6ICdGRVRDSF9QRVJTT05fREFUQScsXG4gICAgICAgICAgICBmZXRjaFN0YXR1czogJ1BFTkRJTkcnLFxuICAgICAgICAgICAgZGF0YVN0YXR1czogJ0FCU0VOVCcsXG4gICAgICAgICAgICBtZXNzYWdlOiBudWxsLFxuICAgICAgICAgICAgbGFzdEZldGNoU3RhdHVzVGltZTogMCxcbiAgICAgICAgICAgIGxhc3REYXRhU3RhdHVzVGltZTogMCxcbiAgICAgICAgICAgIHBlcnNvbklkOiAxMTFcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgICgwLCBfYXN5bmNPcGVyYXRpb25NYW5hZ2VyVXRpbHMucmVnaXN0ZXJBc3luY09wZXJhdGlvbkRlc2NyaXB0b3JzKSh7XG4gICAgICAgICAgZGVzY3JpcHRvcklkOiAnRkVUQ0hfUEVSU09OX0RBVEEnLFxuICAgICAgICAgIHJlcXVpcmVkUGFyYW1zOiBbJ3BlcnNvbklkJ10sXG4gICAgICAgICAgb3BlcmF0aW9uVHlwZTogJ1JFQUQnXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFN0YXRlID0gKDAsIF9hc3luY09wZXJhdGlvbk1hbmFnZXJVdGlscy5nZXRTdGF0ZUZvck9wZXJhdGlvbkFmdGVyU3RlcCkoc3RhdGUsICdSRUpFQ1RfQVNZTkNfT1BFUkFUSU9OJywgJ0ZFVENIX1BFUlNPTl9EQVRBJywge1xuICAgICAgICAgIHBlcnNvbklkOiAxMTFcbiAgICAgICAgfSk7XG4gICAgICAgICgwLCBfY2hhaS5leHBlY3QpKHRyYW5zZm9ybWVkU3RhdGUpLnRvLm5lc3RlZC5pbmNsdWRlKHtcbiAgICAgICAgICAnRkVUQ0hfUEVSU09OX0RBVEFfMTExLmZldGNoU3RhdHVzJzogJ0ZBSUxFRCdcbiAgICAgICAgfSk7XG4gICAgICAgICgwLCBfY2hhaS5leHBlY3QpKHRyYW5zZm9ybWVkU3RhdGUpLnRvLm1hdGNoU25hcHNob3QoJ3VwZGF0ZWQgc3RhdGUgc2hvd2luZyByZWplY3RlZCBhc3luYyBvcGVyYXRpb24nKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGRlc2NyaWJlKCdXUklURSBhc3luYyBvcGVyYXRpb25zJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCB1cGRhdGUgc3RhdGUgdG8gc2hvdyB3cml0ZSBhc3luYyBvcGVyYXRpb24gYXMgcGVuZGluZyBzdGF0ZSBmcm9tIGluaXRpYWwgc3RhdGUnLCAoKSA9PiB7XG4gICAgICAgICgwLCBfYXN5bmNPcGVyYXRpb25NYW5hZ2VyVXRpbHMucmVnaXN0ZXJBc3luY09wZXJhdGlvbkRlc2NyaXB0b3JzKSh7XG4gICAgICAgICAgZGVzY3JpcHRvcklkOiAnVVBEQVRFX1BFUlNPTl9EQVRBJyxcbiAgICAgICAgICByZXF1aXJlZFBhcmFtczogWydwZXJzb25JZCddLFxuICAgICAgICAgIG9wZXJhdGlvblR5cGU6ICdXUklURSdcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkU3RhdGUgPSAoMCwgX2FzeW5jT3BlcmF0aW9uTWFuYWdlclV0aWxzLmdldFN0YXRlRm9yT3BlcmF0aW9uQWZ0ZXJTdGVwKShzdGF0ZSwgJ0JFR0lOX0FTWU5DX09QRVJBVElPTicsICdVUERBVEVfUEVSU09OX0RBVEEnLCB7XG4gICAgICAgICAgcGVyc29uSWQ6IDExMVxuICAgICAgICB9KTtcbiAgICAgICAgKDAsIF9jaGFpLmV4cGVjdCkodHJhbnNmb3JtZWRTdGF0ZSkudG8ubmVzdGVkLmluY2x1ZGUoe1xuICAgICAgICAgICdVUERBVEVfUEVSU09OX0RBVEFfMTExLmZldGNoU3RhdHVzJzogJ1BFTkRJTkcnXG4gICAgICAgIH0pO1xuICAgICAgICAoMCwgX2NoYWkuZXhwZWN0KSh0cmFuc2Zvcm1lZFN0YXRlKS50by5tYXRjaFNuYXBzaG90KCd1cGRhdGVkIHN0YXRlIHNob3dpbmcgcGVuZGluZyB3cml0ZSBhc3luYyBvcGVyYXRpb24nKTtcbiAgICAgIH0pO1xuICAgICAgaXQoJ3Nob3VsZCB1cGRhdGUgc3RhdGUgdG8gc2hvdyB3cml0ZSBhc3luYyBvcGVyYXRpb24gYXMgc3VjY2Vzc2Z1bCBzdGF0ZSBmcm9tIHBlbmRpbmcgc3RhdGUnLCAoKSA9PiB7XG4gICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgIFVQREFURV9QRVJTT05fREFUQV8xMTE6IHtcbiAgICAgICAgICAgIGRlc2NyaXB0b3JJZDogJ1VQREFURV9QRVJTT05fREFUQScsXG4gICAgICAgICAgICBmZXRjaFN0YXR1czogJ1BFTkRJTkcnLFxuICAgICAgICAgICAgbWVzc2FnZTogbnVsbCxcbiAgICAgICAgICAgIGxhc3RGZXRjaFN0YXR1c1RpbWU6IDAsXG4gICAgICAgICAgICBsYXN0RGF0YVN0YXR1c1RpbWU6IDAsXG4gICAgICAgICAgICBwZXJzb25JZDogMTExXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAoMCwgX2FzeW5jT3BlcmF0aW9uTWFuYWdlclV0aWxzLnJlZ2lzdGVyQXN5bmNPcGVyYXRpb25EZXNjcmlwdG9ycykoe1xuICAgICAgICAgIGRlc2NyaXB0b3JJZDogJ1VQREFURV9QRVJTT05fREFUQScsXG4gICAgICAgICAgcmVxdWlyZWRQYXJhbXM6IFsncGVyc29uSWQnXSxcbiAgICAgICAgICBvcGVyYXRpb25UeXBlOiAnV1JJVEUnXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFN0YXRlID0gKDAsIF9hc3luY09wZXJhdGlvbk1hbmFnZXJVdGlscy5nZXRTdGF0ZUZvck9wZXJhdGlvbkFmdGVyU3RlcCkoc3RhdGUsICdSRVNPTFZFX0FTWU5DX09QRVJBVElPTicsICdVUERBVEVfUEVSU09OX0RBVEEnLCB7XG4gICAgICAgICAgcGVyc29uSWQ6IDExMVxuICAgICAgICB9KTtcbiAgICAgICAgKDAsIF9jaGFpLmV4cGVjdCkodHJhbnNmb3JtZWRTdGF0ZSkudG8ubmVzdGVkLmluY2x1ZGUoe1xuICAgICAgICAgICdVUERBVEVfUEVSU09OX0RBVEFfMTExLmZldGNoU3RhdHVzJzogJ1NVQ0NFU1NGVUwnXG4gICAgICAgIH0pO1xuICAgICAgICAoMCwgX2NoYWkuZXhwZWN0KSh0cmFuc2Zvcm1lZFN0YXRlKS50by5tYXRjaFNuYXBzaG90KCd1cGRhdGVkIHN0YXRlIHNob3dpbmcgc3VjY2Vzc2Z1bCB3cml0ZSBhc3luYyBvcGVyYXRpb24nKTtcbiAgICAgIH0pO1xuICAgICAgaXQoJ3Nob3VsZCB1cGRhdGUgc3RhdGUgdG8gc2hvdyB3cml0ZSBhc3luYyBvcGVyYXRpb24gYXMgZmFpbGVkIHN0YXRlIGZyb20gcGVuZGluZyBzdGF0ZScsICgpID0+IHtcbiAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgVVBEQVRFX1BFUlNPTl9EQVRBXzExMToge1xuICAgICAgICAgICAgZGVzY3JpcHRvcklkOiAnVVBEQVRFX1BFUlNPTl9EQVRBJyxcbiAgICAgICAgICAgIGZldGNoU3RhdHVzOiAnUEVORElORycsXG4gICAgICAgICAgICBtZXNzYWdlOiBudWxsLFxuICAgICAgICAgICAgbGFzdEZldGNoU3RhdHVzVGltZTogMCxcbiAgICAgICAgICAgIGxhc3REYXRhU3RhdHVzVGltZTogMCxcbiAgICAgICAgICAgIHBlcnNvbklkOiAxMTFcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgICgwLCBfYXN5bmNPcGVyYXRpb25NYW5hZ2VyVXRpbHMucmVnaXN0ZXJBc3luY09wZXJhdGlvbkRlc2NyaXB0b3JzKSh7XG4gICAgICAgICAgZGVzY3JpcHRvcklkOiAnVVBEQVRFX1BFUlNPTl9EQVRBJyxcbiAgICAgICAgICByZXF1aXJlZFBhcmFtczogWydwZXJzb25JZCddLFxuICAgICAgICAgIG9wZXJhdGlvblR5cGU6ICdXUklURSdcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkU3RhdGUgPSAoMCwgX2FzeW5jT3BlcmF0aW9uTWFuYWdlclV0aWxzLmdldFN0YXRlRm9yT3BlcmF0aW9uQWZ0ZXJTdGVwKShzdGF0ZSwgJ1JFSkVDVF9BU1lOQ19PUEVSQVRJT04nLCAnVVBEQVRFX1BFUlNPTl9EQVRBJywge1xuICAgICAgICAgIHBlcnNvbklkOiAxMTFcbiAgICAgICAgfSk7XG4gICAgICAgICgwLCBfY2hhaS5leHBlY3QpKHRyYW5zZm9ybWVkU3RhdGUpLnRvLm5lc3RlZC5pbmNsdWRlKHtcbiAgICAgICAgICAnVVBEQVRFX1BFUlNPTl9EQVRBXzExMS5mZXRjaFN0YXR1cyc6ICdGQUlMRUQnXG4gICAgICAgIH0pO1xuICAgICAgICAoMCwgX2NoYWkuZXhwZWN0KSh0cmFuc2Zvcm1lZFN0YXRlKS50by5tYXRjaFNuYXBzaG90KCd1cGRhdGVkIHN0YXRlIHNob3dpbmcgZmFpbGVkIHdyaXRlIGFzeW5jIG9wZXJhdGlvbicpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufSk7Il19