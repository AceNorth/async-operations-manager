cfd2aeb4d0b4264026e3af39e91c592c
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getActionForAsyncOperation = exports.rejectWriteAsyncOperation = exports.rejectReadAsyncOperation = exports.resolveWriteAsyncOperation = exports.resolveReadAsyncOperation = exports.beginWriteAsyncOperation = exports.beginReadAsyncOperation = exports.initialWriteAsyncOperationForAction = exports.initialReadAsyncOperationForAction = void 0;

var _lodash = require("lodash");

var _constants = require("./constants");

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
} // An asyncOperation is an object that tracks the status of some data that we fetch from
// somewhere or send to somewhere. Each asyncOperation represents
// a single 'dataset' (which, today, always means a single ajax request -- although that's
// not a fixed constraint), and they're stored in Redux under operation-specific keys.
//
// "read" and "write" operations are *slightly* different, but they work the same way.
//
// The asyncOperation tracks information about:
//  - Our last attempt to fetch or write the data
//  - Whether we have data from a prior successful attempt (for reads only)
//  - The action and params and such that were used to request the data
//
// This file includes standalone functions that transform asyncOperations when we
// begin, resolve, or reject requests. In general, only reducers should use these functions.

/**
 * asyncOperations were originally always treated as proper immutable objects, but for background refreshes
 * it doesn't make sense to create a new object unless the status is actually different somehow, because
 * the new object will cause any screens that select the asyncOperation to rerender.
 *
 * So this is an experiment in having the asyncOperation object be *semi*-immutable: it will only yield
 * a new object instance if there's a noteworthy change in status.
 *
 * @type {boolean}
 */


var alwaysImmutable = false;
/**
 * This is the default look of brand new, never-touched asyncOperation.
 */

var initialReadAsyncOperation = {
  // Note that descriptorId is NOT included here: it MUST be provided!
  fetchStatus: _constants.FETCH_STATUS.NULL,
  dataStatus: _constants.DATA_STATUS.ABSENT,
  message: null,
  lastFetchStatusTime: 0,
  lastFetchFailed: false,
  lastDataStatusTime: 0
};
var initialWriteAsyncOperation = {
  // Note that descriptorId is NOT included here: it MUST be provided!
  fetchStatus: _constants.FETCH_STATUS.NULL,
  message: null,
  lastFetchStatusTime: 0
}; // Note that we'll pull in any status (dataStatus, fetchStatus, etc) from the parent
// operation (which *should* be fetchAllBeveragesForOrg) to seed the initial status.

var initialReadAsyncOperationForAction = function initialReadAsyncOperationForAction(descriptorId) {
  var fieldsToAdd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var parentAsyncOperation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  return _objectSpread({}, initialReadAsyncOperation, parentAsyncOperation ? (0, _lodash.pick)(parentAsyncOperation, _constants.readAsyncOperationFieldsToPullFromParent) : {}, fieldsToAdd, {
    descriptorId: descriptorId
  });
};

exports.initialReadAsyncOperationForAction = initialReadAsyncOperationForAction;

var initialWriteAsyncOperationForAction = function initialWriteAsyncOperationForAction(descriptorId) {
  var fieldsToAdd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return _objectSpread({}, initialWriteAsyncOperation, fieldsToAdd, {
    descriptorId: descriptorId
  });
};
/**
 * These are intended for use in reducers, when a __BEGIN action comes in:
 * For read operations, we'll retain any prior dataStatus, but everything else gets reset.
 * Write operations are always a new, blank backendAsyncOperation.
 *
 * Note that you'll always want to specify `descriptorId` in fieldsToAdd, along with any IDs.
 */


exports.initialWriteAsyncOperationForAction = initialWriteAsyncOperationForAction;

var beginReadAsyncOperation = function beginReadAsyncOperation() {
  var previousAsyncOperation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialReadAsyncOperation;
  var fieldsToAdd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var fieldsForNewAsyncOperation = _objectSpread({
    // We re-initialize the entire operation state (except descriptorId and dataStatus) on __BEGIN.
    // (resolve/reject *don't* re-initialize: they carry through any IDs or other fields from before)
    descriptorId: previousAsyncOperation.descriptorId,
    fetchStatus: _constants.FETCH_STATUS.PENDING,
    dataStatus: previousAsyncOperation.dataStatus,
    message: null,
    lastFetchStatusTime: Date.now(),
    lastDataStatusTime: previousAsyncOperation.lastDataStatusTime
  }, fieldsToAdd);

  if (alwaysImmutable || previousAsyncOperation.dataStatus !== _constants.DATA_STATUS.PRESENT) {
    return fieldsForNewAsyncOperation;
  }

  Object.assign(previousAsyncOperation, fieldsForNewAsyncOperation);
  return previousAsyncOperation;
}; // Note that the 'write' works the same way as 'read', but instead of calling the base
// operation "previousAsyncOperation" we call it "initialAsyncOperation" since its role is different.


exports.beginReadAsyncOperation = beginReadAsyncOperation;

var beginWriteAsyncOperation = function beginWriteAsyncOperation() {
  var initialAsyncOperation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialWriteAsyncOperation;
  var fieldsToAdd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return _objectSpread({
    descriptorId: initialAsyncOperation.descriptorId,
    fetchStatus: _constants.FETCH_STATUS.PENDING,
    message: null,
    lastFetchStatusTime: Date.now()
  }, fieldsToAdd);
};
/**
 * These are intended for use in reducers, when a __RESOLVE action comes in:
 * we'll mark that we have data, and will overwrite any prior data status.
 */


exports.beginWriteAsyncOperation = beginWriteAsyncOperation;

var resolveReadAsyncOperation = function resolveReadAsyncOperation() {
  var previousAsyncOperation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialReadAsyncOperation;
  var fieldsToAdd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var currentTime = Date.now();

  var fieldsToUpdate = _objectSpread({
    fetchStatus: _constants.FETCH_STATUS.SUCCESSFUL,
    dataStatus: _constants.DATA_STATUS.PRESENT,
    lastFetchStatusTime: currentTime,
    lastFetchFailed: false,
    lastDataStatusTime: currentTime
  }, fieldsToAdd);

  if (alwaysImmutable || previousAsyncOperation.lastFetchFailed || previousAsyncOperation.dataStatus !== _constants.DATA_STATUS.PRESENT) {
    return _objectSpread({}, previousAsyncOperation, fieldsToUpdate);
  } // Else: we already had data, and we weren't asked to be immutable, so this isn't a noteworthy change,
  // so mutate in place. (Eep)


  Object.assign(previousAsyncOperation, fieldsToUpdate);
  return previousAsyncOperation;
};

exports.resolveReadAsyncOperation = resolveReadAsyncOperation;

var resolveWriteAsyncOperation = function resolveWriteAsyncOperation() {
  var previousAsyncOperation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialReadAsyncOperation;
  var fieldsToAdd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var currentTime = Date.now();
  return _objectSpread({}, previousAsyncOperation, {
    fetchStatus: _constants.FETCH_STATUS.SUCCESSFUL,
    lastFetchStatusTime: currentTime
  }, fieldsToAdd);
};
/**
 * These are intended for use in reducers, when a __REJECT action comes in:
 * we'll mark that things failed, but won't alter any prior data status (if it's a read).
 *
 * Note that you'll almost always want to specify `message` in fieldsToAdd.
 */


exports.resolveWriteAsyncOperation = resolveWriteAsyncOperation;

var rejectReadAsyncOperation = function rejectReadAsyncOperation() {
  var previousAsyncOperation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialReadAsyncOperation;
  var fieldsToAdd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return _objectSpread({}, previousAsyncOperation, {
    fetchStatus: _constants.FETCH_STATUS.FAILED,
    lastFetchStatusTime: Date.now(),
    lastFetchFailed: true
  }, fieldsToAdd);
};

exports.rejectReadAsyncOperation = rejectReadAsyncOperation;

var rejectWriteAsyncOperation = function rejectWriteAsyncOperation(previousAsyncOperation) {
  var fieldsToAdd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return _objectSpread({}, previousAsyncOperation, {
    fetchStatus: _constants.FETCH_STATUS.FAILED,
    lastFetchStatusTime: Date.now()
  }, fieldsToAdd);
};

exports.rejectWriteAsyncOperation = rejectWriteAsyncOperation;

var getActionForAsyncOperation = function getActionForAsyncOperation(operation, configContainer) {
  var extraParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}; // We're going to pull out all the fields we recognize -- for both Read and Write operations --
  // and anything left over is assumed to be part of the action (i.e., any necessary IDs or params)

  var fetchStatus = operation.fetchStatus,
      dataStatus = operation.dataStatus,
      message = operation.message,
      lastFetchStatusTime = operation.lastFetchStatusTime,
      lastDataStatusTime = operation.lastDataStatusTime,
      descriptorId = operation.descriptorId,
      otherProps = _objectWithoutProperties(operation, ["fetchStatus", "dataStatus", "message", "lastFetchStatusTime", "lastDataStatusTime", "descriptorId"]);

  if (!descriptorId) {
    console.warn('AsyncOperation needs to include descriptorId so that we can re-dispatch it.', operation);
  }

  return _objectSpread({
    type: descriptorId,
    configContainer: configContainer
  }, otherProps, extraParams);
};

exports.getActionForAsyncOperation = getActionForAsyncOperation;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzeW5jT3BlcmF0aW9uVXRpbHMuanMiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXRBY3Rpb25Gb3JBc3luY09wZXJhdGlvbiIsInJlamVjdFdyaXRlQXN5bmNPcGVyYXRpb24iLCJyZWplY3RSZWFkQXN5bmNPcGVyYXRpb24iLCJyZXNvbHZlV3JpdGVBc3luY09wZXJhdGlvbiIsInJlc29sdmVSZWFkQXN5bmNPcGVyYXRpb24iLCJiZWdpbldyaXRlQXN5bmNPcGVyYXRpb24iLCJiZWdpblJlYWRBc3luY09wZXJhdGlvbiIsImluaXRpYWxXcml0ZUFzeW5jT3BlcmF0aW9uRm9yQWN0aW9uIiwiaW5pdGlhbFJlYWRBc3luY09wZXJhdGlvbkZvckFjdGlvbiIsIl9sb2Rhc2giLCJyZXF1aXJlIiwiX2NvbnN0YW50cyIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsInNvdXJjZSIsImV4Y2x1ZGVkIiwidGFyZ2V0IiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UiLCJrZXkiLCJpIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwic291cmNlU3ltYm9sS2V5cyIsImxlbmd0aCIsImluZGV4T2YiLCJwcm90b3R5cGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImNhbGwiLCJzb3VyY2VLZXlzIiwia2V5cyIsIl9vYmplY3RTcHJlYWQiLCJhcmd1bWVudHMiLCJvd25LZXlzIiwiY29uY2F0IiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImFsd2F5c0ltbXV0YWJsZSIsImluaXRpYWxSZWFkQXN5bmNPcGVyYXRpb24iLCJmZXRjaFN0YXR1cyIsIkZFVENIX1NUQVRVUyIsIk5VTEwiLCJkYXRhU3RhdHVzIiwiREFUQV9TVEFUVVMiLCJBQlNFTlQiLCJtZXNzYWdlIiwibGFzdEZldGNoU3RhdHVzVGltZSIsImxhc3RGZXRjaEZhaWxlZCIsImxhc3REYXRhU3RhdHVzVGltZSIsImluaXRpYWxXcml0ZUFzeW5jT3BlcmF0aW9uIiwiZGVzY3JpcHRvcklkIiwiZmllbGRzVG9BZGQiLCJ1bmRlZmluZWQiLCJwYXJlbnRBc3luY09wZXJhdGlvbiIsInBpY2siLCJyZWFkQXN5bmNPcGVyYXRpb25GaWVsZHNUb1B1bGxGcm9tUGFyZW50IiwicHJldmlvdXNBc3luY09wZXJhdGlvbiIsImZpZWxkc0Zvck5ld0FzeW5jT3BlcmF0aW9uIiwiUEVORElORyIsIkRhdGUiLCJub3ciLCJQUkVTRU5UIiwiYXNzaWduIiwiaW5pdGlhbEFzeW5jT3BlcmF0aW9uIiwiY3VycmVudFRpbWUiLCJmaWVsZHNUb1VwZGF0ZSIsIlNVQ0NFU1NGVUwiLCJGQUlMRUQiLCJvcGVyYXRpb24iLCJjb25maWdDb250YWluZXIiLCJleHRyYVBhcmFtcyIsIm90aGVyUHJvcHMiLCJjb25zb2xlIiwid2FybiIsInR5cGUiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBQSxNQUFNLENBQUNDLGNBQVAsQ0FBc0JDLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQzNDQyxFQUFBQSxLQUFLLEVBQUU7QUFEb0MsQ0FBN0M7QUFHQUQsT0FBTyxDQUFDRSwwQkFBUixHQUFxQ0YsT0FBTyxDQUFDRyx5QkFBUixHQUFvQ0gsT0FBTyxDQUFDSSx3QkFBUixHQUFtQ0osT0FBTyxDQUFDSywwQkFBUixHQUFxQ0wsT0FBTyxDQUFDTSx5QkFBUixHQUFvQ04sT0FBTyxDQUFDTyx3QkFBUixHQUFtQ1AsT0FBTyxDQUFDUSx1QkFBUixHQUFrQ1IsT0FBTyxDQUFDUyxtQ0FBUixHQUE4Q1QsT0FBTyxDQUFDVSxrQ0FBUixHQUE2QyxLQUFLLENBQTFWOztBQUVBLElBQUlDLE9BQU8sR0FBR0MsT0FBTyxDQUFDLFFBQUQsQ0FBckI7O0FBRUEsSUFBSUMsVUFBVSxHQUFHRCxPQUFPLENBQUMsYUFBRCxDQUF4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cEM7QUFBQSxNQUlJRSxrQkFBa0IsR0FBR29CLFNBQVMsQ0FBQ3BCLGtCQUpuQztBQUFBLE1BS0lFLFlBQVksR0FBR2tCLFNBQVMsQ0FBQ2xCLFlBTDdCO0FBQUEsTUFNSXFCLFVBQVUsR0FBRy9ELHdCQUF3QixDQUFDNEQsU0FBRCxFQUFZLENBQUMsYUFBRCxFQUFnQixZQUFoQixFQUE4QixTQUE5QixFQUF5QyxxQkFBekMsRUFBZ0Usb0JBQWhFLEVBQXNGLGNBQXRGLENBQVosQ0FOekM7O0FBUUEsTUFBSSxDQUFDbEIsWUFBTCxFQUFtQjtBQUNqQnNCLElBQUFBLE9BQU8sQ0FBQ0MsSUFBUixDQUFhLDZFQUFiLEVBQTRGTCxTQUE1RjtBQUNEOztBQUVELFNBQU81QyxhQUFhLENBQUM7QUFDbkJrRCxJQUFBQSxJQUFJLEVBQUV4QixZQURhO0FBRW5CbUIsSUFBQUEsZUFBZSxFQUFFQTtBQUZFLEdBQUQsRUFHakJFLFVBSGlCLEVBR0xELFdBSEssQ0FBcEI7QUFJRCxDQXJCRDs7QUF1QkE1RSxPQUFPLENBQUNFLDBCQUFSLEdBQXFDQSwwQkFBckMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0QWN0aW9uRm9yQXN5bmNPcGVyYXRpb24gPSBleHBvcnRzLnJlamVjdFdyaXRlQXN5bmNPcGVyYXRpb24gPSBleHBvcnRzLnJlamVjdFJlYWRBc3luY09wZXJhdGlvbiA9IGV4cG9ydHMucmVzb2x2ZVdyaXRlQXN5bmNPcGVyYXRpb24gPSBleHBvcnRzLnJlc29sdmVSZWFkQXN5bmNPcGVyYXRpb24gPSBleHBvcnRzLmJlZ2luV3JpdGVBc3luY09wZXJhdGlvbiA9IGV4cG9ydHMuYmVnaW5SZWFkQXN5bmNPcGVyYXRpb24gPSBleHBvcnRzLmluaXRpYWxXcml0ZUFzeW5jT3BlcmF0aW9uRm9yQWN0aW9uID0gZXhwb3J0cy5pbml0aWFsUmVhZEFzeW5jT3BlcmF0aW9uRm9yQWN0aW9uID0gdm9pZCAwO1xuXG52YXIgX2xvZGFzaCA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5cbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgdmFyIG93bktleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpIHsgb3duS2V5cyA9IG93bktleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKS5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTsgfSkpOyB9IG93bktleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8vIEFuIGFzeW5jT3BlcmF0aW9uIGlzIGFuIG9iamVjdCB0aGF0IHRyYWNrcyB0aGUgc3RhdHVzIG9mIHNvbWUgZGF0YSB0aGF0IHdlIGZldGNoIGZyb21cbi8vIHNvbWV3aGVyZSBvciBzZW5kIHRvIHNvbWV3aGVyZS4gRWFjaCBhc3luY09wZXJhdGlvbiByZXByZXNlbnRzXG4vLyBhIHNpbmdsZSAnZGF0YXNldCcgKHdoaWNoLCB0b2RheSwgYWx3YXlzIG1lYW5zIGEgc2luZ2xlIGFqYXggcmVxdWVzdCAtLSBhbHRob3VnaCB0aGF0J3Ncbi8vIG5vdCBhIGZpeGVkIGNvbnN0cmFpbnQpLCBhbmQgdGhleSdyZSBzdG9yZWQgaW4gUmVkdXggdW5kZXIgb3BlcmF0aW9uLXNwZWNpZmljIGtleXMuXG4vL1xuLy8gXCJyZWFkXCIgYW5kIFwid3JpdGVcIiBvcGVyYXRpb25zIGFyZSAqc2xpZ2h0bHkqIGRpZmZlcmVudCwgYnV0IHRoZXkgd29yayB0aGUgc2FtZSB3YXkuXG4vL1xuLy8gVGhlIGFzeW5jT3BlcmF0aW9uIHRyYWNrcyBpbmZvcm1hdGlvbiBhYm91dDpcbi8vICAtIE91ciBsYXN0IGF0dGVtcHQgdG8gZmV0Y2ggb3Igd3JpdGUgdGhlIGRhdGFcbi8vICAtIFdoZXRoZXIgd2UgaGF2ZSBkYXRhIGZyb20gYSBwcmlvciBzdWNjZXNzZnVsIGF0dGVtcHQgKGZvciByZWFkcyBvbmx5KVxuLy8gIC0gVGhlIGFjdGlvbiBhbmQgcGFyYW1zIGFuZCBzdWNoIHRoYXQgd2VyZSB1c2VkIHRvIHJlcXVlc3QgdGhlIGRhdGFcbi8vXG4vLyBUaGlzIGZpbGUgaW5jbHVkZXMgc3RhbmRhbG9uZSBmdW5jdGlvbnMgdGhhdCB0cmFuc2Zvcm0gYXN5bmNPcGVyYXRpb25zIHdoZW4gd2Vcbi8vIGJlZ2luLCByZXNvbHZlLCBvciByZWplY3QgcmVxdWVzdHMuIEluIGdlbmVyYWwsIG9ubHkgcmVkdWNlcnMgc2hvdWxkIHVzZSB0aGVzZSBmdW5jdGlvbnMuXG5cbi8qKlxuICogYXN5bmNPcGVyYXRpb25zIHdlcmUgb3JpZ2luYWxseSBhbHdheXMgdHJlYXRlZCBhcyBwcm9wZXIgaW1tdXRhYmxlIG9iamVjdHMsIGJ1dCBmb3IgYmFja2dyb3VuZCByZWZyZXNoZXNcbiAqIGl0IGRvZXNuJ3QgbWFrZSBzZW5zZSB0byBjcmVhdGUgYSBuZXcgb2JqZWN0IHVubGVzcyB0aGUgc3RhdHVzIGlzIGFjdHVhbGx5IGRpZmZlcmVudCBzb21laG93LCBiZWNhdXNlXG4gKiB0aGUgbmV3IG9iamVjdCB3aWxsIGNhdXNlIGFueSBzY3JlZW5zIHRoYXQgc2VsZWN0IHRoZSBhc3luY09wZXJhdGlvbiB0byByZXJlbmRlci5cbiAqXG4gKiBTbyB0aGlzIGlzIGFuIGV4cGVyaW1lbnQgaW4gaGF2aW5nIHRoZSBhc3luY09wZXJhdGlvbiBvYmplY3QgYmUgKnNlbWkqLWltbXV0YWJsZTogaXQgd2lsbCBvbmx5IHlpZWxkXG4gKiBhIG5ldyBvYmplY3QgaW5zdGFuY2UgaWYgdGhlcmUncyBhIG5vdGV3b3J0aHkgY2hhbmdlIGluIHN0YXR1cy5cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xudmFyIGFsd2F5c0ltbXV0YWJsZSA9IGZhbHNlO1xuLyoqXG4gKiBUaGlzIGlzIHRoZSBkZWZhdWx0IGxvb2sgb2YgYnJhbmQgbmV3LCBuZXZlci10b3VjaGVkIGFzeW5jT3BlcmF0aW9uLlxuICovXG5cbnZhciBpbml0aWFsUmVhZEFzeW5jT3BlcmF0aW9uID0ge1xuICAvLyBOb3RlIHRoYXQgZGVzY3JpcHRvcklkIGlzIE5PVCBpbmNsdWRlZCBoZXJlOiBpdCBNVVNUIGJlIHByb3ZpZGVkIVxuICBmZXRjaFN0YXR1czogX2NvbnN0YW50cy5GRVRDSF9TVEFUVVMuTlVMTCxcbiAgZGF0YVN0YXR1czogX2NvbnN0YW50cy5EQVRBX1NUQVRVUy5BQlNFTlQsXG4gIG1lc3NhZ2U6IG51bGwsXG4gIGxhc3RGZXRjaFN0YXR1c1RpbWU6IDAsXG4gIGxhc3RGZXRjaEZhaWxlZDogZmFsc2UsXG4gIGxhc3REYXRhU3RhdHVzVGltZTogMFxufTtcbnZhciBpbml0aWFsV3JpdGVBc3luY09wZXJhdGlvbiA9IHtcbiAgLy8gTm90ZSB0aGF0IGRlc2NyaXB0b3JJZCBpcyBOT1QgaW5jbHVkZWQgaGVyZTogaXQgTVVTVCBiZSBwcm92aWRlZCFcbiAgZmV0Y2hTdGF0dXM6IF9jb25zdGFudHMuRkVUQ0hfU1RBVFVTLk5VTEwsXG4gIG1lc3NhZ2U6IG51bGwsXG4gIGxhc3RGZXRjaFN0YXR1c1RpbWU6IDBcbn07IC8vIE5vdGUgdGhhdCB3ZSdsbCBwdWxsIGluIGFueSBzdGF0dXMgKGRhdGFTdGF0dXMsIGZldGNoU3RhdHVzLCBldGMpIGZyb20gdGhlIHBhcmVudFxuLy8gb3BlcmF0aW9uICh3aGljaCAqc2hvdWxkKiBiZSBmZXRjaEFsbEJldmVyYWdlc0Zvck9yZykgdG8gc2VlZCB0aGUgaW5pdGlhbCBzdGF0dXMuXG5cbnZhciBpbml0aWFsUmVhZEFzeW5jT3BlcmF0aW9uRm9yQWN0aW9uID0gZnVuY3Rpb24gaW5pdGlhbFJlYWRBc3luY09wZXJhdGlvbkZvckFjdGlvbihkZXNjcmlwdG9ySWQpIHtcbiAgdmFyIGZpZWxkc1RvQWRkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIHBhcmVudEFzeW5jT3BlcmF0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICByZXR1cm4gX29iamVjdFNwcmVhZCh7fSwgaW5pdGlhbFJlYWRBc3luY09wZXJhdGlvbiwgcGFyZW50QXN5bmNPcGVyYXRpb24gPyAoMCwgX2xvZGFzaC5waWNrKShwYXJlbnRBc3luY09wZXJhdGlvbiwgX2NvbnN0YW50cy5yZWFkQXN5bmNPcGVyYXRpb25GaWVsZHNUb1B1bGxGcm9tUGFyZW50KSA6IHt9LCBmaWVsZHNUb0FkZCwge1xuICAgIGRlc2NyaXB0b3JJZDogZGVzY3JpcHRvcklkXG4gIH0pO1xufTtcblxuZXhwb3J0cy5pbml0aWFsUmVhZEFzeW5jT3BlcmF0aW9uRm9yQWN0aW9uID0gaW5pdGlhbFJlYWRBc3luY09wZXJhdGlvbkZvckFjdGlvbjtcblxudmFyIGluaXRpYWxXcml0ZUFzeW5jT3BlcmF0aW9uRm9yQWN0aW9uID0gZnVuY3Rpb24gaW5pdGlhbFdyaXRlQXN5bmNPcGVyYXRpb25Gb3JBY3Rpb24oZGVzY3JpcHRvcklkKSB7XG4gIHZhciBmaWVsZHNUb0FkZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkKHt9LCBpbml0aWFsV3JpdGVBc3luY09wZXJhdGlvbiwgZmllbGRzVG9BZGQsIHtcbiAgICBkZXNjcmlwdG9ySWQ6IGRlc2NyaXB0b3JJZFxuICB9KTtcbn07XG4vKipcbiAqIFRoZXNlIGFyZSBpbnRlbmRlZCBmb3IgdXNlIGluIHJlZHVjZXJzLCB3aGVuIGEgX19CRUdJTiBhY3Rpb24gY29tZXMgaW46XG4gKiBGb3IgcmVhZCBvcGVyYXRpb25zLCB3ZSdsbCByZXRhaW4gYW55IHByaW9yIGRhdGFTdGF0dXMsIGJ1dCBldmVyeXRoaW5nIGVsc2UgZ2V0cyByZXNldC5cbiAqIFdyaXRlIG9wZXJhdGlvbnMgYXJlIGFsd2F5cyBhIG5ldywgYmxhbmsgYmFja2VuZEFzeW5jT3BlcmF0aW9uLlxuICpcbiAqIE5vdGUgdGhhdCB5b3UnbGwgYWx3YXlzIHdhbnQgdG8gc3BlY2lmeSBgZGVzY3JpcHRvcklkYCBpbiBmaWVsZHNUb0FkZCwgYWxvbmcgd2l0aCBhbnkgSURzLlxuICovXG5cblxuZXhwb3J0cy5pbml0aWFsV3JpdGVBc3luY09wZXJhdGlvbkZvckFjdGlvbiA9IGluaXRpYWxXcml0ZUFzeW5jT3BlcmF0aW9uRm9yQWN0aW9uO1xuXG52YXIgYmVnaW5SZWFkQXN5bmNPcGVyYXRpb24gPSBmdW5jdGlvbiBiZWdpblJlYWRBc3luY09wZXJhdGlvbigpIHtcbiAgdmFyIHByZXZpb3VzQXN5bmNPcGVyYXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGluaXRpYWxSZWFkQXN5bmNPcGVyYXRpb247XG4gIHZhciBmaWVsZHNUb0FkZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgdmFyIGZpZWxkc0Zvck5ld0FzeW5jT3BlcmF0aW9uID0gX29iamVjdFNwcmVhZCh7XG4gICAgLy8gV2UgcmUtaW5pdGlhbGl6ZSB0aGUgZW50aXJlIG9wZXJhdGlvbiBzdGF0ZSAoZXhjZXB0IGRlc2NyaXB0b3JJZCBhbmQgZGF0YVN0YXR1cykgb24gX19CRUdJTi5cbiAgICAvLyAocmVzb2x2ZS9yZWplY3QgKmRvbid0KiByZS1pbml0aWFsaXplOiB0aGV5IGNhcnJ5IHRocm91Z2ggYW55IElEcyBvciBvdGhlciBmaWVsZHMgZnJvbSBiZWZvcmUpXG4gICAgZGVzY3JpcHRvcklkOiBwcmV2aW91c0FzeW5jT3BlcmF0aW9uLmRlc2NyaXB0b3JJZCxcbiAgICBmZXRjaFN0YXR1czogX2NvbnN0YW50cy5GRVRDSF9TVEFUVVMuUEVORElORyxcbiAgICBkYXRhU3RhdHVzOiBwcmV2aW91c0FzeW5jT3BlcmF0aW9uLmRhdGFTdGF0dXMsXG4gICAgbWVzc2FnZTogbnVsbCxcbiAgICBsYXN0RmV0Y2hTdGF0dXNUaW1lOiBEYXRlLm5vdygpLFxuICAgIGxhc3REYXRhU3RhdHVzVGltZTogcHJldmlvdXNBc3luY09wZXJhdGlvbi5sYXN0RGF0YVN0YXR1c1RpbWVcbiAgfSwgZmllbGRzVG9BZGQpO1xuXG4gIGlmIChhbHdheXNJbW11dGFibGUgfHwgcHJldmlvdXNBc3luY09wZXJhdGlvbi5kYXRhU3RhdHVzICE9PSBfY29uc3RhbnRzLkRBVEFfU1RBVFVTLlBSRVNFTlQpIHtcbiAgICByZXR1cm4gZmllbGRzRm9yTmV3QXN5bmNPcGVyYXRpb247XG4gIH1cblxuICBPYmplY3QuYXNzaWduKHByZXZpb3VzQXN5bmNPcGVyYXRpb24sIGZpZWxkc0Zvck5ld0FzeW5jT3BlcmF0aW9uKTtcbiAgcmV0dXJuIHByZXZpb3VzQXN5bmNPcGVyYXRpb247XG59OyAvLyBOb3RlIHRoYXQgdGhlICd3cml0ZScgd29ya3MgdGhlIHNhbWUgd2F5IGFzICdyZWFkJywgYnV0IGluc3RlYWQgb2YgY2FsbGluZyB0aGUgYmFzZVxuLy8gb3BlcmF0aW9uIFwicHJldmlvdXNBc3luY09wZXJhdGlvblwiIHdlIGNhbGwgaXQgXCJpbml0aWFsQXN5bmNPcGVyYXRpb25cIiBzaW5jZSBpdHMgcm9sZSBpcyBkaWZmZXJlbnQuXG5cblxuZXhwb3J0cy5iZWdpblJlYWRBc3luY09wZXJhdGlvbiA9IGJlZ2luUmVhZEFzeW5jT3BlcmF0aW9uO1xuXG52YXIgYmVnaW5Xcml0ZUFzeW5jT3BlcmF0aW9uID0gZnVuY3Rpb24gYmVnaW5Xcml0ZUFzeW5jT3BlcmF0aW9uKCkge1xuICB2YXIgaW5pdGlhbEFzeW5jT3BlcmF0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBpbml0aWFsV3JpdGVBc3luY09wZXJhdGlvbjtcbiAgdmFyIGZpZWxkc1RvQWRkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe1xuICAgIGRlc2NyaXB0b3JJZDogaW5pdGlhbEFzeW5jT3BlcmF0aW9uLmRlc2NyaXB0b3JJZCxcbiAgICBmZXRjaFN0YXR1czogX2NvbnN0YW50cy5GRVRDSF9TVEFUVVMuUEVORElORyxcbiAgICBtZXNzYWdlOiBudWxsLFxuICAgIGxhc3RGZXRjaFN0YXR1c1RpbWU6IERhdGUubm93KClcbiAgfSwgZmllbGRzVG9BZGQpO1xufTtcbi8qKlxuICogVGhlc2UgYXJlIGludGVuZGVkIGZvciB1c2UgaW4gcmVkdWNlcnMsIHdoZW4gYSBfX1JFU09MVkUgYWN0aW9uIGNvbWVzIGluOlxuICogd2UnbGwgbWFyayB0aGF0IHdlIGhhdmUgZGF0YSwgYW5kIHdpbGwgb3ZlcndyaXRlIGFueSBwcmlvciBkYXRhIHN0YXR1cy5cbiAqL1xuXG5cbmV4cG9ydHMuYmVnaW5Xcml0ZUFzeW5jT3BlcmF0aW9uID0gYmVnaW5Xcml0ZUFzeW5jT3BlcmF0aW9uO1xuXG52YXIgcmVzb2x2ZVJlYWRBc3luY09wZXJhdGlvbiA9IGZ1bmN0aW9uIHJlc29sdmVSZWFkQXN5bmNPcGVyYXRpb24oKSB7XG4gIHZhciBwcmV2aW91c0FzeW5jT3BlcmF0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBpbml0aWFsUmVhZEFzeW5jT3BlcmF0aW9uO1xuICB2YXIgZmllbGRzVG9BZGQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gIHZhciBmaWVsZHNUb1VwZGF0ZSA9IF9vYmplY3RTcHJlYWQoe1xuICAgIGZldGNoU3RhdHVzOiBfY29uc3RhbnRzLkZFVENIX1NUQVRVUy5TVUNDRVNTRlVMLFxuICAgIGRhdGFTdGF0dXM6IF9jb25zdGFudHMuREFUQV9TVEFUVVMuUFJFU0VOVCxcbiAgICBsYXN0RmV0Y2hTdGF0dXNUaW1lOiBjdXJyZW50VGltZSxcbiAgICBsYXN0RmV0Y2hGYWlsZWQ6IGZhbHNlLFxuICAgIGxhc3REYXRhU3RhdHVzVGltZTogY3VycmVudFRpbWVcbiAgfSwgZmllbGRzVG9BZGQpO1xuXG4gIGlmIChhbHdheXNJbW11dGFibGUgfHwgcHJldmlvdXNBc3luY09wZXJhdGlvbi5sYXN0RmV0Y2hGYWlsZWQgfHwgcHJldmlvdXNBc3luY09wZXJhdGlvbi5kYXRhU3RhdHVzICE9PSBfY29uc3RhbnRzLkRBVEFfU1RBVFVTLlBSRVNFTlQpIHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZCh7fSwgcHJldmlvdXNBc3luY09wZXJhdGlvbiwgZmllbGRzVG9VcGRhdGUpO1xuICB9IC8vIEVsc2U6IHdlIGFscmVhZHkgaGFkIGRhdGEsIGFuZCB3ZSB3ZXJlbid0IGFza2VkIHRvIGJlIGltbXV0YWJsZSwgc28gdGhpcyBpc24ndCBhIG5vdGV3b3J0aHkgY2hhbmdlLFxuICAvLyBzbyBtdXRhdGUgaW4gcGxhY2UuIChFZXApXG5cblxuICBPYmplY3QuYXNzaWduKHByZXZpb3VzQXN5bmNPcGVyYXRpb24sIGZpZWxkc1RvVXBkYXRlKTtcbiAgcmV0dXJuIHByZXZpb3VzQXN5bmNPcGVyYXRpb247XG59O1xuXG5leHBvcnRzLnJlc29sdmVSZWFkQXN5bmNPcGVyYXRpb24gPSByZXNvbHZlUmVhZEFzeW5jT3BlcmF0aW9uO1xuXG52YXIgcmVzb2x2ZVdyaXRlQXN5bmNPcGVyYXRpb24gPSBmdW5jdGlvbiByZXNvbHZlV3JpdGVBc3luY09wZXJhdGlvbigpIHtcbiAgdmFyIHByZXZpb3VzQXN5bmNPcGVyYXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGluaXRpYWxSZWFkQXN5bmNPcGVyYXRpb247XG4gIHZhciBmaWVsZHNUb0FkZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkKHt9LCBwcmV2aW91c0FzeW5jT3BlcmF0aW9uLCB7XG4gICAgZmV0Y2hTdGF0dXM6IF9jb25zdGFudHMuRkVUQ0hfU1RBVFVTLlNVQ0NFU1NGVUwsXG4gICAgbGFzdEZldGNoU3RhdHVzVGltZTogY3VycmVudFRpbWVcbiAgfSwgZmllbGRzVG9BZGQpO1xufTtcbi8qKlxuICogVGhlc2UgYXJlIGludGVuZGVkIGZvciB1c2UgaW4gcmVkdWNlcnMsIHdoZW4gYSBfX1JFSkVDVCBhY3Rpb24gY29tZXMgaW46XG4gKiB3ZSdsbCBtYXJrIHRoYXQgdGhpbmdzIGZhaWxlZCwgYnV0IHdvbid0IGFsdGVyIGFueSBwcmlvciBkYXRhIHN0YXR1cyAoaWYgaXQncyBhIHJlYWQpLlxuICpcbiAqIE5vdGUgdGhhdCB5b3UnbGwgYWxtb3N0IGFsd2F5cyB3YW50IHRvIHNwZWNpZnkgYG1lc3NhZ2VgIGluIGZpZWxkc1RvQWRkLlxuICovXG5cblxuZXhwb3J0cy5yZXNvbHZlV3JpdGVBc3luY09wZXJhdGlvbiA9IHJlc29sdmVXcml0ZUFzeW5jT3BlcmF0aW9uO1xuXG52YXIgcmVqZWN0UmVhZEFzeW5jT3BlcmF0aW9uID0gZnVuY3Rpb24gcmVqZWN0UmVhZEFzeW5jT3BlcmF0aW9uKCkge1xuICB2YXIgcHJldmlvdXNBc3luY09wZXJhdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogaW5pdGlhbFJlYWRBc3luY09wZXJhdGlvbjtcbiAgdmFyIGZpZWxkc1RvQWRkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe30sIHByZXZpb3VzQXN5bmNPcGVyYXRpb24sIHtcbiAgICBmZXRjaFN0YXR1czogX2NvbnN0YW50cy5GRVRDSF9TVEFUVVMuRkFJTEVELFxuICAgIGxhc3RGZXRjaFN0YXR1c1RpbWU6IERhdGUubm93KCksXG4gICAgbGFzdEZldGNoRmFpbGVkOiB0cnVlXG4gIH0sIGZpZWxkc1RvQWRkKTtcbn07XG5cbmV4cG9ydHMucmVqZWN0UmVhZEFzeW5jT3BlcmF0aW9uID0gcmVqZWN0UmVhZEFzeW5jT3BlcmF0aW9uO1xuXG52YXIgcmVqZWN0V3JpdGVBc3luY09wZXJhdGlvbiA9IGZ1bmN0aW9uIHJlamVjdFdyaXRlQXN5bmNPcGVyYXRpb24ocHJldmlvdXNBc3luY09wZXJhdGlvbikge1xuICB2YXIgZmllbGRzVG9BZGQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICByZXR1cm4gX29iamVjdFNwcmVhZCh7fSwgcHJldmlvdXNBc3luY09wZXJhdGlvbiwge1xuICAgIGZldGNoU3RhdHVzOiBfY29uc3RhbnRzLkZFVENIX1NUQVRVUy5GQUlMRUQsXG4gICAgbGFzdEZldGNoU3RhdHVzVGltZTogRGF0ZS5ub3coKVxuICB9LCBmaWVsZHNUb0FkZCk7XG59O1xuXG5leHBvcnRzLnJlamVjdFdyaXRlQXN5bmNPcGVyYXRpb24gPSByZWplY3RXcml0ZUFzeW5jT3BlcmF0aW9uO1xuXG52YXIgZ2V0QWN0aW9uRm9yQXN5bmNPcGVyYXRpb24gPSBmdW5jdGlvbiBnZXRBY3Rpb25Gb3JBc3luY09wZXJhdGlvbihvcGVyYXRpb24sIGNvbmZpZ0NvbnRhaW5lcikge1xuICB2YXIgZXh0cmFQYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gIC8vIFdlJ3JlIGdvaW5nIHRvIHB1bGwgb3V0IGFsbCB0aGUgZmllbGRzIHdlIHJlY29nbml6ZSAtLSBmb3IgYm90aCBSZWFkIGFuZCBXcml0ZSBvcGVyYXRpb25zIC0tXG4gIC8vIGFuZCBhbnl0aGluZyBsZWZ0IG92ZXIgaXMgYXNzdW1lZCB0byBiZSBwYXJ0IG9mIHRoZSBhY3Rpb24gKGkuZS4sIGFueSBuZWNlc3NhcnkgSURzIG9yIHBhcmFtcylcbiAgdmFyIGZldGNoU3RhdHVzID0gb3BlcmF0aW9uLmZldGNoU3RhdHVzLFxuICAgICAgZGF0YVN0YXR1cyA9IG9wZXJhdGlvbi5kYXRhU3RhdHVzLFxuICAgICAgbWVzc2FnZSA9IG9wZXJhdGlvbi5tZXNzYWdlLFxuICAgICAgbGFzdEZldGNoU3RhdHVzVGltZSA9IG9wZXJhdGlvbi5sYXN0RmV0Y2hTdGF0dXNUaW1lLFxuICAgICAgbGFzdERhdGFTdGF0dXNUaW1lID0gb3BlcmF0aW9uLmxhc3REYXRhU3RhdHVzVGltZSxcbiAgICAgIGRlc2NyaXB0b3JJZCA9IG9wZXJhdGlvbi5kZXNjcmlwdG9ySWQsXG4gICAgICBvdGhlclByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9wZXJhdGlvbiwgW1wiZmV0Y2hTdGF0dXNcIiwgXCJkYXRhU3RhdHVzXCIsIFwibWVzc2FnZVwiLCBcImxhc3RGZXRjaFN0YXR1c1RpbWVcIiwgXCJsYXN0RGF0YVN0YXR1c1RpbWVcIiwgXCJkZXNjcmlwdG9ySWRcIl0pO1xuXG4gIGlmICghZGVzY3JpcHRvcklkKSB7XG4gICAgY29uc29sZS53YXJuKCdBc3luY09wZXJhdGlvbiBuZWVkcyB0byBpbmNsdWRlIGRlc2NyaXB0b3JJZCBzbyB0aGF0IHdlIGNhbiByZS1kaXNwYXRjaCBpdC4nLCBvcGVyYXRpb24pO1xuICB9XG5cbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe1xuICAgIHR5cGU6IGRlc2NyaXB0b3JJZCxcbiAgICBjb25maWdDb250YWluZXI6IGNvbmZpZ0NvbnRhaW5lclxuICB9LCBvdGhlclByb3BzLCBleHRyYVBhcmFtcyk7XG59O1xuXG5leHBvcnRzLmdldEFjdGlvbkZvckFzeW5jT3BlcmF0aW9uID0gZ2V0QWN0aW9uRm9yQXN5bmNPcGVyYXRpb247Il19